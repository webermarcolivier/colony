Colony Example
In this notebook, we will show how to setup the executable and the input files for the Colony software, and analyze the data. We implement a simplified version of the Ising model.
Notebook options to improve readability on git repository
SetOptions[InputNotebook[],PrivateNotebookOptions->{"FileOutlineCache"->False},TrackCellChangeTimes->False]
Directories definition [need user input]
pathPrefix="/home/mweber/sonyz1/Research/Simulations/Output/Gene_expression_noise_example";
(*Directory where to write the input files, usually where we run the Colony executable.*)
inputFileDirectory=pathPrefix;
(*Directory where to write the output files of the simulations.*)
outputDirectory=pathPrefix;
(*Directory of the Colony source code. Part of the C++ functions are written by this Mathematica notebook into this directory as cpp files.*)
sourceDirectory="/media/MyPassportBlue/Data/Research/Simulations/Colony";
General mathematica definitions (version 2013.12.12)
Definition of font size and image size for graphs
(*Note: these are absolute values of reference for the font size and image size of all graphs in the notebook. They are meant to be used in all the graphs and can be multiplied by a custom coefficient.*)
fontsize=18;
imagesize=500;
fontFamily="Arial";
String representation of numbers
Several functions to convert numbers to string. In particular, the fixed scientific form is very useful for outputting numbers the same way the C++ program does. The converting methods already implemented in Mathematica, such as ScientificForm, do not give the desired output (try to output examples below).
latexnumber[x_,precision_Integer]:=ScientificForm[x,precision,NumberFormat->(ToString[#1<>"\\cdot "<>#2<>"^{"<>#3<>"}"]&)]
Print["latexnumber[1.3453*^6,4] = ",latexnumber[1.3453*^6,4]];

intstring[k_,digits_:3]:=StringDrop[ToString[PaddedForm[k,digits,NumberPadding->{"0",""}]],{1,1}];
Print["intstring[3,4] = ",intstring[3,4]];

numberString[x_,precision_,digits_]:=ToString[PaddedForm[x,{precision,digits},NumberPadding->{"","0"}]]
Print["numberString[1.54323,2,1] = ",numberString[1.54323,2,1]];
Print["numberString[100.0,3,0] = ",numberString[100.0,3,0]];
Print["numberString[100.456734523,5,6] = ",numberString[100.456734523,5,6]];

fixedScientificForm[number_,digitsToTheRightOfDecimalPoint_]:=ScientificForm[N[number,digitsToTheRightOfDecimalPoint+1],digitsToTheRightOfDecimalPoint+1,NumberFormat->((Row[{
If[StringLength[#1]==1,
#1<>"."<>StringJoin[Table["0",{digitsToTheRightOfDecimalPoint+2-StringLength[#1]-1+If[number<0,1,0]}]],
#1<>StringJoin[Table["0",{digitsToTheRightOfDecimalPoint+2-StringLength[#1]+If[number<0,1,0]}]]],
"e",
ToString[PaddedForm[If[ToExpression[#3]===Null,0,ToExpression[#3]],2,NumberPadding->{"0",""},SignPadding->True,NumberSigns->{"-","+"}]]}])&)];
Print["fixedScientificForm[0.012,3] = ",fixedScientificForm[0.012,3]];
Print["fixedScientificForm[-0.012,3] = ",fixedScientificForm[-0.012,3]];
Print["fixedScientificForm[0.0123456,3] = ",fixedScientificForm[0.0123456,3]];
Print["fixedScientificForm[-0.0123456,3] = ",fixedScientificForm[-0.0123456,3]];
Print["fixedScientificForm[300,3] = ",fixedScientificForm[300,3]];
Print["fixedScientificForm[5,3] = ",fixedScientificForm[5,3]];
Print["fixedScientificForm[1.,3] = ",fixedScientificForm[1.,3]];
Print["fixedScientificForm[0.,3] = ",fixedScientificForm[0.,3]];
Print["fixedScientificForm[0,3] = ",fixedScientificForm[0,3]];

Improved plot markers
These are just examples to be copy pasted in graphs. Improved plot markers of different shapes with a white background.
With dynamic color of the plot markers
ListPlot[
{1.2Range[0,10,1],1.6Range[0,10,1]}
,Joined->True,
PlotMarkers:>{{
With[{plotMarkerThickness=0.1},
Graphics[{Dynamic@EdgeForm[{CurrentValue["Color"],Thickness[plotMarkerThickness]}],FaceForm[White],Disk[{0,0},1]},PlotRangePadding->Scaled[plotMarkerThickness/2]]
]
,0.05}}
]
Defining a list of plot styles for color of plot markers
Module[{plotStyleList},
plotStyleList=Thread[{
{Disk[{0,0},1],Rectangle[]},
{Blue,Red}
}];
ListPlot[
{1.2Range[0,10,1],1.6Range[0,10,1]}
,Joined->True,
PlotStyle->(#[[2]]&/@plotStyleList),
PlotMarkers:>
({
With[{plotMarkerThickness=0.1},
Graphics[{EdgeForm[{#[[2]],Thickness[plotMarkerThickness]}],FaceForm[White],#[[1]]},PlotRangePadding->Scaled[plotMarkerThickness/2]]
]
,0.05}&/@plotStyleList)
]
]
Plot legend
Plots the legend inset.
legendPlottext[xl_List,colorlist_List:{},symbolList_List:{},graphSizeCoeff_:1,lineLength_:20,frameMargins_:5]:=Panel[Grid[MapIndexed[{
Graphics[
Flatten[{
If[colorlist=={},ColorData[1,First@#2],Extract[colorlist,First@#2]],
Thickness[0.1],Line[{{-1,0},{1,0}}],
If[symbolList=={},
{},
Inset[symbolList[[First@#2]],{0,0},{0,0},1*{1,1}]
]
}],ImageSize->{graphSizeCoeff*lineLength,Automatic},AspectRatio->1/1.2],
Style[#1,FontSize-> graphSizeCoeff*fontsize,FontFamily->fontFamily]}&,xl],
Alignment->{Left,Center},Spacings->graphSizeCoeff*{0.5,0.}],FrameMargins->graphSizeCoeff*frameMargins];
Simple example
legendPlottext[{xx,yy},{{Blue,Dashed,Dashing[{0.2,0.2}]},Red},{},2]
Example inset in a plot that has defined all the plot styles for the lines and plot markers
Module[{plotStyleList,plotMarkerFunction,graphSizeCoeff=1},

plotStyleList=Thread[{
{Disk[{0,0},1],Rectangle[{-1,-1},{1,1}]},
{Blue,Red}
}];
Print["plotStyleList = ",plotStyleList];

plotMarkerFunction=With[{plotMarkerThickness=0.1},
Graphics[{EdgeForm[{#[[2]],Thickness[plotMarkerThickness]}],FaceForm[White],#[[1]]},PlotRangePadding->Scaled[plotMarkerThickness/2]]
]&;
Print["plotMarkerFunction/@plotStyleList = ",plotMarkerFunction/@plotStyleList];

ListPlot[
{1.2Range[0,10,1],1.6Range[0,10,1]}
,Joined->True,
PlotStyle->(#[[2]]&/@plotStyleList),
PlotMarkers:>({#,0.04}&/@(plotMarkerFunction/@plotStyleList)),ImageSize->graphSizeCoeff*imagesize,
Epilog->Inset[legendPlottext[{"xx","yy"},plotStyleList[[All,2]],(plotMarkerFunction/@plotStyleList),graphSizeCoeff],Scaled[{0.05,0.95}],{Left,Top}]
]
]
Convert hexadecimal color from the web to decimal RGB color
hexToRGB=RGBColor@@(IntegerDigits[ToExpression@StringReplace[#,"#"->"16^^"],256,3]/255.)&;
hexToRGB["#FF8000"]
Parameters [need user input]
par={
(*Reaction rates are defined in terms of concentration nM and dimensionless time units.*)
(*See below definition of the system of reaction for the meaning of the parameters*)
α2->α1,β2->β1,α1->1,β1->10,
K1->1*expressionLevel,K2->K1,expressionLevel->0.5,
Dx->1*^-2(*coefficient of diffusion*),
nCells->50(*initial number of cells in the colony*),
r->V0/Vext(*ratio of the initial volume of a cell at the beginning of cell cycle to the initial external volume*),
(*nconc0: initial cell density in cells/μm^3*)
(*Option 1: fixing the cell density*)
(*nconc0->1*^9(*cells/mL*)*1*^3(*cells/L*)*1*^-15(*cells/μm^3*),*)
(*Option 2: fixing the ratio rtot=nCells*Vcell/Vext*)
Solve[nCells/Vx==1/.(Vx->(Vtot-nCells V0)/V0)/.Vtot->nCells/nconc0,{nconc0}][[1,1]],
V0->1.5(*μm^3*)(*volume of the cell at the beginning of the cell cycle*),
L0->2.5,
r0->0.44,
cellLength0->2(*μm*)(*length of the cell at the beginning of the cell cycle*),
cellHeight0->1(*μm*)(*width of the cell at the beginning of the cell cycle*)
}
Definition of the system of reactions [need user input at volume correction]
Set cell growth, cell volume and area
cellgrowth=False;
First the total volume is determined based on the cell density and the number of cells.
Vtot=nCells/nconc0(*cells/μm^3*)(*μm^3*);
Then the volume ratio Vx is determined based on Vtot, V0 and nCells, inverse of r.
Vx=(Vtot-nCells V0)/V0;
Vext=Vx V0;
Conversion coefficient molecules per cell -> nM
nmolesV0=1*^9/6.02214*^23  *1/(V0*1*^-15);
nmolesVext=1*^9/6.02214*^23  *1/(Vext*1*^-15);
V0 is replaced by the average of the cell volume over a cell cycle in the case of the exponential growth, V1=1/Log[2] V0, in order to compare correctly the deterministic model (with fixed cell volume) to the stochastic model (with dynamic growth).
nmolesV1=1*^9/6.02214*^23  *1/(V0/Log[2]*1*^-15);

(*Conversion function cell density cells/mL <--> number of cells*)
nconc[n_]:=n/(Vtot*1*^-12)/.par;(* n -> # cells/mL *)
concn[x_]:=(Vtot*1*^-12)*x/.par;(* # cells/mL -> n *)(* # cells/mL -> # cells*)
List of species [need user input]
speciesCell={U,V};
speciesMilieu={Ue,Ve};

If[Length[Intersection[speciesCell,speciesMilieu]]!=0,Print["ERROR: the species cannot have the same name in the cell and in the milieu.",Intersection[speciesCell,speciesMilieu]];];
species=Join[speciesCell,speciesMilieu];
nSCell=Length[speciesCell];Print["Number of chemical species in 1 cell, nSCell = ",nSCell]
nSMilieu=Length[speciesMilieu];Print["Number of chemical species in the milieu, nSMilieu = ",nSMilieu]
S=nSCell+nSMilieu;Print["Total number of chemical species: S = ",S]
xCell=Table[speciesCell[[i]][t],{i,nSCell}]; Print["Table of species variables in the cell, xCell = ",xCell]
xMilieu=Table[speciesMilieu[[i]][t],{i,nSMilieu}]; Print["Table of species variables in the milieu, xMilieu = ",xMilieu]
x=Join[xCell,xMilieu]; Print["Table of species variables, x = ",x]
pos[s_,species_]:=Extract[Position[species,s],{1,1}] ;
pos[s_]:=pos[s,species];
Print["pos[x,speciesTable] gives the position of a species x in the speciesTable. Example: pos[Ve,species] = ",pos[Ve,species]]
Set of reactions [need user input]
Please keep the structure of the tables.
A reaction in the cell or in the milieu is written as a list:
{{reactants list},{products list},{1 if forward reaction is active 0 otherwise,1 if backward reaction is active 0 otherwise},{rate of forward reaction,rate of backward reaction}}
Note that the stochiometric coefficient can be introduced by repeating the species name, as in {{U,U,U,V},{B},{1,1},{kf,kb}}.
The reactions of molecule transport accross the membrane (diffusion) can be written the same way. 
(*Note: the degradation rate is equal to unity.*)
reacCell={
{{},{U},{1,1},{α1+(β1 K1^3)/(K1^3+(V[t])^3),1}},
{{},{V},{1,1},{α2+(β2 K2^3)/(K2^3+(U[t])^3),1}}
};

reacMilieu={Ue}	{}	{1,0}	{1,0}
{Ve}	{}	{1,0}	{1,0}

;

reacCellMilieu={U}	{Ue}	{1,1}	{Dx,Dx}
{V}	{Ve}	{1,1}	{Dx,Dx}

;
reac=Join[reacCell,reacMilieu,reacCellMilieu];

nRCell=Length[reacCell];Print["Number of reactions in cell: ",nRCell]
nRMilieu=Length[reacMilieu];Print["Number of reactions in milieu: ",nRMilieu]
nRCellMilieu=Length[reacCellMilieu];Print["Number of reactions cell-milieu: ",nRCellMilieu]
R=Length[reac];Print["Number of total reactions: ",R]
dnaCell=Table[0,{nSCell},{nSCell}];
Array defining genetic species.
 *int array of size nSpecies x nSpecies.\n
   *This array defines which species are genetic material and which are
   *proteins.It is used to define which species are halved and which species
   *are copied during a division event.It is defined the following way :
  *
   *On the diagonal, for\c i == \c j :
    < table >
     < tr > < td > \code dnaSpecies_ (i, i) = 0\endcode
      < td > if species\c i is a protein = > will be halved during division event. < /tr >
   < tr > < td > \code dnaSpecies_ (i, i) = 1\endcode
      < td > if species\c i is a protein - DNA complex = > will be
unbound before division event. < /tr >
  < tr > < td > \code dnaSpecies_ (i, i) = -1\endcode
      < td > if species\c i is a DNA molecule = > will be
copied during division event. < /tr >
 < /table > In the bulk matrix, for\c i != \c j :
    < table >
     < tr > < td > \code dnaSpecies_ (i, j) = n_ij\endcode
      < td > If species\c i is a protein or a DNA molecule, then\code n_ij = 0
          \endcode for all\c j.If species\c i is a protein - DNA complex, then\c n_ij
define the stoichiometric vector of the
unbounding reaction.In other words, it means
that the protein - DNA complex is formed of :
   \code n_i0*species0 + n_i1*species1 + ...\endcode < /tr >
    < /table >
Example :
dnaCell=Table[0,{nSCell},{nSCell}];
dnaCell[[pos[P00,speciesCell],pos[P00,speciesCell]]]=-1;
dnaCell[[pos[P01,speciesCell],pos[P01,speciesCell]]]=1;
dnaCell[[pos[P01,speciesCell],pos[P00,speciesCell]]]=1;
dnaCell[[pos[P01,speciesCell],pos[AL2,speciesCell]]]=1;
dnaCell[[pos[P10,speciesCell],pos[P10,speciesCell]]]=1;
dnaCell[[pos[P10,speciesCell],pos[P00,speciesCell]]]=1;
dnaCell[[pos[P10,speciesCell],pos[AL2,speciesCell]]]=1;
dnaCell[[pos[P11,speciesCell],pos[P11,speciesCell]]]=1;
dnaCell[[pos[P11,speciesCell],pos[P00,speciesCell]]]=1;
dnaCell[[pos[P11,speciesCell],pos[AL2,speciesCell]]]=2;
Print["dnaCell: ",dnaCell//MatrixForm]
Reactions rates
Definition of the reactions rates for the deterministic approach and for the Gillespie stochastic approach.

kp=right and km=left reaction rates
For a spatially homogeneous mixture of chemical species, the microscopic rate of a chemical reaction depends on physical properties of the molecules and the temperature of the system, assumed constant. For a second-order reaction, A+B->E, the probability that a collision will occur in volume V(t) in the next infinitesimal time interval (t,t+dt) writes [1]
Subscript[X, A] Subscript[X, B] V(t)^-1 π Subscript[r, 12]^2 Overscript[Subscript[v, 12], _] dt.
At thermal equilibrium and if the collision has a probability Subscript[p, 12] of activating a reaction, the total reaction probability that a reaction will occur is
Subscript[X, A] Subscript[X, B] V(t)^-1 π Subscript[r, 12]^2 Overscript[Subscript[v, 12], _]  Subscript[p, 12]dt=Subscript[X, A] Subscript[X, B] c dt,
where
c=V (t)^-1 π Subscript[r, 12]^2 Overscript[Subscript[v, 12], _] Subscript[p, 12] is called the stochastic reaction constant.
If we define
V(t)=V^*(t) Subscript[V, 0],
we can write the stochastic reaction constant as
c(t)=1/(V^*(t) Subscript[V, 0]) π Subscript[r, 12]^2 Overscript[Subscript[v, 12], _] Subscript[p, 12]=(1/V^*(t) ) Subscript[c, 0] , where everything is constant and depends on physical properties of the system, except the volume which is variable.  Note that Subscript[c, 0] is adimensional.
The average number of molecules of E produced per unit of time is
Subscript[X, E]'(t)=Subscript[X, A] Subscript[X, B] c(t),
and the change in concentration in E (without considering the dilution term) is
(Subscript[X, E]'(t))/V(t)=Subscript[X, A]/V(t) Subscript[X, B] c(t)=Subscript[X, A]/V(t) Subscript[X, B]/V(t) c(t)V(t)=c(t) V(t)Subscript[c, A] Subscript[c, B].
The deterministic rate write
k=c(t) V(t) = Subscript[c, 0] V(t)/V^*(t)=Subscript[c, 0] Subscript[V, 0],
and does not change with the volume. Herein we define the deterministic rates and derive the stochastic reaction constants, because the deterministic rates do not depend on the volume and are usually measured experimentally (contrary to the stochastic reaction constants). The derived stochastic reaction rate writes Subscript[c, 0]=k/Subscript[V, 0]=k*nmolesV0.

1. Gillespie D. Exact stochastic simulation of coupled chemical reactions. The journal of physical chemistry. 1977;81(25):2340–2361.
(*kp and km are the kinetic rates for the deterministic approach.*)
kpCell=Table[reacCell[[i,4,1]],{i,nRCell}];
kmCell=Table[reacCell[[i,4,2]],{i,nRCell}];
Print["kpCell: ",kpCell]
Print["kmCell: ",kmCell]

(*cp and cm are the rates of transition for the Gillespie algorithm*)
cpCell=Table[reacCell[[i,4,1]]*nmolesV0^(Length[reacCell[[i,1]]]-1),{i,nRCell}]/.Thread[x->x*nmolesV0];
cmCell=Table[reacCell[[i,4,2]]*nmolesV0^(Length[reacCell[[i,2]]]-1),{i,nRCell}]/.Thread[x->x*nmolesV0];
Print["cpCell: ",cpCell]
Print["cmCell: ",cmCell]

cpMilieu=Table[reacMilieu[[i,4,1]]*nmolesVext^(Length[reacMilieu[[i,1]]]-1),{i,nRMilieu}];
cmMilieu=Table[reacMilieu[[i,4,2]]*nmolesVext^(Length[reacMilieu[[i,2]]]-1),{i,nRMilieu}];
Print["cpMilieu: ",cpMilieu]
Print["cmMilieu: ",cmMilieu]
kpMilieu=Table[reacMilieu[[i,4,1]],{i,nRMilieu}];
kmMilieu=Table[reacMilieu[[i,4,2]],{i,nRMilieu}];
Print["kpMilieu: ",kpMilieu]
Print["kmMilieu: ",kmMilieu]

cpCellMilieu=Table[reacCellMilieu[[i,4,1]],{i,nRCellMilieu}];
cmCellMilieu=Table[reacCellMilieu[[i,4,2]],{i,nRCellMilieu}];
Print["cpCellMilieu: ",cpCellMilieu]
Print["cmCellMilieu: ",cmCellMilieu]

(*cp and cm are the rates of transition for the Gillespie algorithm*)
cp=Join[cpCell,cpMilieu,cpCellMilieu];
cm=Join[cmCell,cmMilieu,cmCellMilieu];
If[Length[cp]!=R||Length[cm]!=R,Print["Error: length of cp or cm is not equal to the number of reactions"]]

(*kp and km are the kinetic rates for the deterministic approach.*)
kp=reac[[All,4,1]];
km=reac[[All,4,2]];
Print["cp: ",cp]
Print["cm: ",cm]
Print["kp: ",kp]
Print["km: ",km]
Compute deterministic equations
Definition of reaction matrix
systemCell={speciesCell,nSCell,nRCell,reacCell,"Cell"};
systemMilieu={speciesMilieu,nSMilieu,nRMilieu,reacMilieu,"Milieu"};
systemTotal={species,S,R,reac,"Total"};

Do[
Module[{
species=system[[1]],
S=system[[2]],
R=system[[3]],
reac=system[[4]]},
NP1=Table[Table[Count[reac[[i]][[1]],species[[j]]],{j,1,S}],{i,1,R}];
NM1=Table[Table[Count[reac[[i]][[2]],species[[j]]],{j,1,S}],{i,1,R}];
NR1=NM1-NP1;
NV1=Join[NR1,-NR1];

If[system[[5]]=="Cell",NRCell=NR1;NVCell=NV1; NPCell=NP1; NMCell=NM1];
If[system[[5]]=="Milieu",NRMilieu=NR1;NVMilieu=NV1; NPMilieu=NP1; NMMilieu=NM1];
If[system[[5]]=="Total",NR=NR1;NV=NV1; NP=NP1; NM=NM1];

(*Print set of reactions*)
reacdiagram=Grid[Table[{i,Sum[NP1[[i]][[j]]species[[j]],{j,1,S}], If[Part[reac,i,3,1]==0&&Part[reac,i,3,2]!=0,"←",If[Part[reac,i,3,2]==0&&Part[reac,i,3,1]!=0,"→",If[Part[reac,i,3,2]!=0&&Part[reac,i,3,1]!=0,"⇄",If[Part[reac,i,3,2]==0&&Part[reac,i,3,1]==0,""]]]],Sum[NM1[[i]][[j]]species[[j]],{j,1,S}]},{i,1,R}],Alignment->{{Left,Right,Center,Left}}];

Clear[NP1,NM1,NR1,NV1];
]
,{system,{systemCell,systemMilieu,systemTotal}}];
Print[Style[reacdiagram,FontSize->16]];
Clear[systemCell,systemMilieu,systemTotal];

NPCellMilieu=
Table[
Table[Count[reacCellMilieu[[i,1]],species[[j]]],{j,1,S}]
,{i,nRCellMilieu}];
NMCellMilieu=
Table[
Table[Count[reacCellMilieu[[i,2]],species[[j]]],{j,1,S}]
,{i,nRCellMilieu}];
NRCellMilieu=NMCellMilieu-NPCellMilieu;
NVCellMilieu=Join[NRCellMilieu,-NRCellMilieu];

Compute deterministic equations
(*Define kinetic equations for each species*)
prod[x_]:=Product[x[[i]],{i,Length[x]}]/.Table[species[[i]]->species[[i]][t],{i,S}];
equfill=Table[0,{S}];
(*For each reaction, forward and backward, we fill the equations for corresponding involved species*)
Do[Do[
equfill[[i]]+=-Part[reac,j,3,1]NP[[j]][[i]]kp[[j]]prod[Part[reac,j,1]]+Part[reac,j,3,2]NP[[j]][[i]]km[[j]]prod[Part[reac,j,2]];
equfill[[i]]+=+Part[reac,j,3,1]NM[[j]][[i]]kp[[j]]prod[Part[reac,j,1]]-Part[reac,j,3,2]NM[[j]][[i]]km[[j]]prod[Part[reac,j,2]];
,{i,S}],{j,R}];
ADD DILUTION TERM :
All species inside the cell are being diluted at a rate -Log[2]/τ.
Note: As the noise terms will be computed based on the reaction matrix NV and the rate of reactions, not the deterministic equations, these additional dilution terms will not be included in the noise terms. We don't want to include noise in the dilution process, we consider cell growth as a deterministic process (although the cell cycle duration can be stochastic).
If[cellgrowth,
Module[{splist,t1},
splist=pos/@Select[species,#=!=Ue&&#=!=Ve&];
Do[
equfill[[k]]+=-(Log[2]/tau)x[[k]];(*dilution term*)
,{k,splist}];
]
]
VOLUME RATIO CORRECTION FOR DIFFUSION:
We multiply the reaction rate for the diffusion in the equation for the diffusing molecules in the milieu by the coefficient 1/Vnx, in order to satisfy mass conservation (the volumes for which concentrations of A and Aext are defined are different). Here Vnx is the ratio of the total volume to the volume of one cell. It depends on the cell density nconc0. 
Module[{
listOfDiffusingChemicalSpeciesInMilieu=Union[Flatten[reacCellMilieu[[All,2]]]],
listOfDiffusionRatesChemicalSpeciesInMilieu=Union[Flatten[reacCellMilieu[[All,4,2]]]],
listRuleDiffusionRateVolumeCorrection
},
listRuleDiffusionRateVolumeCorrection=(#-># V0/Vext)&/@listOfDiffusionRatesChemicalSpeciesInMilieu;
Print["listRuleDiffusionRateVolumeCorrection = ",listRuleDiffusionRateVolumeCorrection];
Do[
Print["equation for ",u," before correction = ",equfill[[pos[u]]]];
equfill[[pos[u]]]=equfill[[pos[u]]]/.listRuleDiffusionRateVolumeCorrection;
Print["equation for ",u," after correction = ",equfill[[pos[u]]]];
,{u,listOfDiffusingChemicalSpeciesInMilieu}]
]
WRITE EQUATIONS :
equ=Table[D[x[[i]],t]==equfill[[i]],{i,1,S}];

If[cellgrowth,equ2=equ;,equ1=equ;];
Style["Kinetic equations",FontSize->18]
If[!cellgrowth,Style[equ//TableForm,FontSize->18]]
If[cellgrowth,Style[equ//TableForm,FontSize->18]]
Compute the Langevin noise terms
The chemical Langevin equation writes
Subscript[dX, i](t)/dt=
UnderoverscriptBox[∑, j = 1, M]
SubscriptBox[ν, ji] 
SubscriptBox[a, j](X(t))+
UnderoverscriptBox[∑, j = 1, M]
SubscriptBox[ν, ji] 
SuperscriptBox[
SubscriptBox[a, j], 1/2](X(t)) 
SubscriptBox[Γ, j](t)
where M is the number of reaction channels, Subscript[ν, ij] the change in number of species Subscript[S, i] molecules produced by one Subscript[R, j] reaction, Subscript[a, j](X(t)) the propensity of reaction Subscript[R, j] and Subscript[Γ, j](t) are temporally uncorrelated, statistically independent Gaussian white noises.

We can rewrite this Langevin equation into a standard-form Langevin equation,
Subscript[dX, i](t)/dt=Subscript[A, i](X(t),t)+
StyleBox[
UnderoverscriptBox["∑", 
RowBox[{"j", "=", "1"}], "M"],
FontSize->16]
SubscriptBox[B, ij](X(t), t) 
StyleBox[
RowBox[{
SubscriptBox["Γ", "j"], "(", "t", ")"}],
FontSize->16]
with
Subscript[A, i](x,t)=
UnderoverscriptBox[∑, j = 1, M]
SubscriptBox[
StyleBox["⋁",
FontSize->16], "ji"]
SubscriptBox[a, j](x)
Subscript[B, ij](x,t)=
SubscriptBox[
StyleBox["⋁",
FontSize->16], "ji"]
SuperscriptBox[
SubscriptBox[a, j], 1/2](x)
See this blog post for more details: http://www.marcweber.net/labnotebook/?p=1505#Multivariate_Langevin_and_Fokker-Planck_equations
We develop the terms aj for all the cells, from the definition of the reaction in 1 cell. We build a global system with the reactions in the following order:
Reactions table = [reactions in cell 1, ..., reactions in cell N, reactions in Milieu, reactions cell 1 <-> milieu, ..., reactions cell N <-> milieu].
Species table = [species in cell 1, ..., species in cell N, species in Milieu].
Compute the reaction rates aj
Here, aj depend on the deterministic rates and species concentrations.
aj=Module[{ajReacP,ajReacM,replaceVariablesByVariablesWithCellIndex},

replaceVariablesByVariablesWithCellIndex=Thread[x->species]/.Thread[species->Join[#[i][t]&/@speciesCell,#[t]&/@speciesMilieu]];

ajReacP=Table[reac[[j,3,1]]kp[[j]]Product[reac[[j,1,i]],{i,Length[reac[[j,1]]]}],{j,R}]/.Thread[x->species]/.Thread[species->Join[#[i][t]&/@speciesCell,#[t]&/@speciesMilieu]];
ajReacM=Table[reac[[j,3,2]]km[[j]]Product[reac[[j,2,i]],{i,Length[reac[[j,2]]]}],{j,R}]/.Thread[x->species]/.Thread[species->Join[#[i][t]&/@speciesCell,#[t]&/@speciesMilieu]];

Join[
Flatten[Table[ajReacP[[1;;nRCell]],{i,nCells/.par}]],
ajReacP[[nRCell+1;;nRCell+nRMilieu]],
Flatten[Table[ajReacP[[nRCell+nRMilieu+1;;-1]],{i,nCells/.par}]],
Flatten[Table[ajReacM[[1;;nRCell]],{i,nCells/.par}]],
ajReacM[[nRCell+1;;nRCell+nRMilieu]],
Flatten[Table[ajReacM[[nRCell+nRMilieu+1;;-1]],{i,nCells/.par}]]
]
];
aj
Build the NV reactions matrix for the complete nCells system
Here we build the reactions matrix NV for the complete system of N cells with diffusion reactions.
NVLangevin=Table[0,{2*((nRCell+nRCellMilieu)*nCells+nRMilieu)/.par},{(nSCell*nCells+nSMilieu)/.par}];
Module[{nCells1=nCells/.par},

Do[
NVLangevin[[(iCell-1)*nRCell+1;;iCell*nRCell,
(iCell-1)*nSCell+1;;iCell*nSCell]]
=NRCell;
,{iCell,nCells1}];

NVLangevin[[nCells1*nRCell+1;;nCells1*nRCell+nRMilieu,
nCells1*nSCell+1;;nCells1*nSCell+nSMilieu]]
=NRMilieu;

Do[

NVLangevin[[
nCells1*nRCell+nRMilieu+(iCell-1)*nRCellMilieu+1;;nCells1*nRCell+nRMilieu+iCell*nRCellMilieu
,
Join[(*Indices of species in cell i*)Range[(iCell-1)*nSCell+1,iCell*nSCell]
,(*Indices of species in milieu*)Range[nCells1*nSCell+1,nCells1*nSCell+nSMilieu]]
]]=NRCellMilieu;

,{iCell,nCells1}];

NVLangevin[[nCells1*nRCell+nRMilieu+nCells1*nRCellMilieu+1;;-1]]=-NVLangevin[[1;;nCells1*nRCell+nRMilieu+nCells1*nRCellMilieu]];
];
NVLangevin
Build the noise terms matrix Bnoise
Bnoise=Table[
NVLangevin[[k,i]]Sqrt[aj[[k]]]
,{i,(nCells/.par)*nSCell+nSMilieu}
,{k,2*((nCells/.par)*nRCell+nRMilieu+(nCells/.par)*nRCellMilieu)}
];
G=Bnoise.Transpose[Bnoise];
Volume correction of the diffusion reactions
Module[{
listOfDiffusingChemicalSpeciesInMilieu=Union[Flatten[reacCellMilieu[[All,2]]]],
listOfDiffusionRatesChemicalSpeciesInMilieu=Union[Flatten[reacCellMilieu[[All,4,2]]]],
listRuleDiffusionRateVolumeCorrection
},
listRuleDiffusionRateVolumeCorrection=(#-># 1/Vx)&/@listOfDiffusionRatesChemicalSpeciesInMilieu;
Print["listRuleDiffusionRateVolumeCorrection = ",listRuleDiffusionRateVolumeCorrection];
Do[
Print["Bnoise for ",u," before correction = ",Bnoise[[(nCells/.par)*nSCell+pos[u,speciesMilieu]]]];
Bnoise[[(nCells/.par)*nSCell+pos[u,speciesMilieu]]]=Bnoise[[(nCells/.par)*nSCell+pos[u,speciesMilieu]]]/.listRuleDiffusionRateVolumeCorrection;
Print["Bnoise for ",u," after correction = ",Bnoise[[(nCells/.par)*nSCell+pos[u,speciesMilieu]]]];
,{u,listOfDiffusingChemicalSpeciesInMilieu}]
]
Bnoise
Write definition files for c++ code CLE integration algorithm
Parameters and initial conditions [need user input]
In the following we define the initial conditions and the configuration file for the simulations.
In each simulation run, we can define a set of global parameters, let say {Subscript[p, 1],Subscript[p, 2],Subscript[p, 3]} that we want to change in different simulation runs. These will be then treated as input parameters in the simulation and can have different values for each simulation run, for example changing the number of cells, a production rate, etc. Moreover, these global parameters can also be changed during the timecourse of a simulation. The time points when the value of {Subscript[p, 1],Subscript[p, 2],Subscript[p, 3]} change are defined in the table simTimePoints.The global parameters have a constant value inside each time interval, i.e. they follow a multiple step functions. Note that Length[simTimePoints] must be equal to Dimensions[globalParSet][[2]]. Example:
globalParList = {{p1}, {p2}};
simTimePoints = {10, 15, 50};
globalParSet = {{{5., 10.}, {6., 12.}, {7., 9.}}, {{3., 8.}, {3.2, 7.}, {3.5, 6.}}};
Plot[
{
Piecewise[{#[[1]],#[[2,1]]<=t<#[[2,2]]}&/@Thread[{globalParSet[[1,All,1]],Partition[Join[{0},simTimePoints],2,1]}]]/.t->t
,
Piecewise[{#[[1]],#[[2,1]]<=t<#[[2,2]]}&/@Thread[{globalParSet[[1,All,2]],Partition[Join[{0},simTimePoints],2,1]}]]/.t->t
},
{t,0,simTimePoints[[-1]]},PlotRange->{0,15},PlotLabel->"Simulation run #1",Epilog->Inset[legendPlottext[Flatten[globalParList]],Scaled[{0.95,0.9}],{Right,Top}]]
Plot[
{
Piecewise[{#[[1]],#[[2,1]]<=t<#[[2,2]]}&/@Thread[{globalParSet[[2,All,1]],Partition[Join[{0},simTimePoints],2,1]}]]/.t->t
,
Piecewise[{#[[1]],#[[2,1]]<=t<#[[2,2]]}&/@Thread[{globalParSet[[2,All,2]],Partition[Join[{0},simTimePoints],2,1]}]]/.t->t
},
{t,0,simTimePoints[[-1]]},PlotRange->{0,15},PlotLabel->"Simulation run #2",Epilog->Inset[legendPlottext[Flatten[globalParList]],Scaled[{0.95,0.9}],{Right,Top}]]
(*Choose algorithm.*)
algorithm="Langevin";
algorithm="Gillespie";

(*Define different sets of experiments.*)
experiment="Coupling";(*Varying the diffusion coefficient for a fixed size colony.*)
experiment="ExponentialGrowth";(*Simulating an exponentially growing colony.*)
experiment="ExternalMagneticField";(*Varying the external field signal for a fixed sized colony.*)

experiment="Coupling";(*Varying the diffusion coefficient for a fixed size colony.*)

Print["V1 = ",V1//.par];
Print["Vtot = ",Vtot//.par];
Print["Vx = ",Vx//.par];
Print["Vext = ",Vext//.par];
(*For exponential growth, the phase corresponding to the average volume V1 is given by*)
phaseV1=N[-Log[Log[2]]/Log[2]];

constantCellDensity=True;(*Keep the cell density constant (number of cells in the population).*)
cellCycleDeterministic=tau//.par;
cellCycleGamma=0.8;
timeMeshSliceLength=1;(*Length of the time mesh intervals to record trajectories.*)
chemicalLangevinTimeStep=1*^-4;
nTimeStepsIntervalDisplaySimulationProgress=Round[10/timeMeshSliceLength];(*Display some simulation progress information in the standard output every n time steps.*)
spatialDynamicsEquilibrationTime=50;(*Presimulation time during which only the spatial movement of cells are computed, to start with a nicely packed colony. Only useful for movies.*)
firstPassageGFPThreshold=0;(*Threshold in concentration for computing first passage time.*)
computeSpatialDynamics=False;(*Compute spatial dynamics for making movie.*)
iseed=Random[Integer,1000000];(*Seed for random number generator.*)
Print["iseed = ",iseed];

Switch[experiment,
"Coupling",
path=outputDirectory<>"/Coupling";
inputFilePath=inputFileDirectory<>"/Coupling";
,
"ExponentialGrowth",
path=outputDirectory<>"/ExponentialGrowth";
inputFilePath=inputFileDirectory<>"/ExponentialGrowth";
,
"ExternalMagneticField",
path=outputDirectory<>"/ExternalMagneticField";
inputFilePath=inputFileDirectory<>"/ExternalMagneticField";
];

Switch[algorithm,
"Langevin",
path=path<>"/Langevin";
inputFilePath=inputFilePath<>"/Langevin";
,
"Gillespie",
path=path<>"/Gillespie";
inputFilePath=inputFilePath<>"/Gillespie";
];



Switch[experiment,

"Coupling"
,
(*Here we modify the par table to exclude the parameters that we want to change for the simulations.*)
par=Select[par,#[[1]]=!=Dx&];

simulationTime=20000;
nTrajectories=10;
simTimePoints={simulationTime};

changeTimeStepWithDiffusion=True;(*Adjust the Langevin time step depending on the diffusion rate.*)
nTimeStepsIntervalDisplaySimulationProgress=Round[simulationTime/timeMeshSliceLength/100];

(*In globalParList only the name of the parameters is important*)
globalParList={{Dx,0}};
(*In globalParSet are the values of the parameter sets.*)
globalParSet=Partition[Partition[N[Join[{0.001,0.01,0.05},Range[0.1,0.4,0.1],Range[0.45,1.5,0.05],Range[1.6,4,0.2],{5,6,7,8,9,10}]],1],1];
globalParSet={{{0}},{{1*^-3}},{{1*^-2}},{{1*^-1}},{{1}},{{1*^1}},{{1*^2}},{{5*^2}},{{1*^3}},{{1*^4}}};

(*Multithreading. Here we split the different paremeters sets into small chunks that will be run by different threads. We write as many input files as number of threads.*)
nParameterPerThread=1;
multiThreadingGlobalParIndicesTable=Partition[Range[Length[globalParSet]],nParameterPerThread];

(*globalPar is the list of rules of replacement.*)
globalPar=#[[1]]->#[[2]]&/@globalParList;
nGlobalParSet=Dimensions[globalParSet][[1]];

x0CellHeterogeneous=True;(*different initial conditions for each cell in the colony*)
x0CellChangingWithGlobalPar=False;(*different initial conditions for each simulation run of parameter set*)
x0MilieuChangingWithGlobalPar=False;

(*Initial conditions in number of molecules.*)
If[x0CellChangingWithGlobalPar,
If[x0CellHeterogeneous
,
x0CellGeneralTable=Table[{
Join[
Table[Round[{1,10}/nmolesV1],{Floor[(nCells//.par)/2]}],
Table[Round[{10,1}/nmolesV1],{(nCells-Floor[nCells/2])//.par}]
],
Table[CForm[phaseV1],{nCells//.par}]
},{iGlobalPar,nGlobalParSet}];
,
x0CellGeneralTable=Table[
Round[{5,5}/nmolesV1//.par]
,{nGlobalParSet}];
];
,
If[x0CellHeterogeneous
,
(*We set half of the cells to the stable state 1 and the other half to the stable state 2.*)
x0CellHeterogeneousTable=Join[
Table[Round[{1,10}/nmolesV1//.par],{Floor[(nCells//.par)/2]}],
Table[Round[{10,1}/nmolesV1//.par],{(nCells-Floor[nCells/2])//.par}]
];
phase0CellHeterogeneousTable=Table[CForm[phaseV1],{nCells//.par}];
x0CellGeneralTable={x0CellHeterogeneousTable,phase0CellHeterogeneousTable};
,
x0CellGeneralTable=x0Cell;
];
];

x0Milieu={0,0};
If[x0MilieuChangingWithGlobalPar,
(*Add AIxAdded nM of autoinducer at the beginning*)
x0MilieuGeneralTable=Table[Round[x0Milieu/nmolesVext],{i,nGlobalParSet}];
,
x0MilieuGeneralTable=Round[x0Milieu/nmolesVext];
];

outputPath=path;
inputFilePath=inputFilePath;

,
"ExponentialGrowth"
,
(*Here we modify the par table to exclude the parameters that we want to change for the simulations.*)
par=Join[Select[par,#[[1]]=!=nCells&&#[[1]]=!=nconc0&&#[[1]]=!=tau&],{nCells->1,Solve[nCells/Vx==1/400,{nconc0}][[1,1]],tau->50}];

simulationTime=N[Log[2,(360/nCells//.par)]]*tau//.par;
stopWhenReachingMaximumVolume=True;
timeMeshSliceLength=0.05;
cellCycleDeterministic=tau//.par;
spatialDynamicsEquilibrationTime=0;
computeSpatialDynamics=True;
firstPassageGFPThreshold=0;
nTrajectories=1;
changeTimeStepWithDiffusion=True;
simTimePoints={simulationTime};
nTimeStepsIntervalDisplaySimulationProgress=Round[simulationTime/timeMeshSliceLength/100];
(*In globalParList only the name of the parameters is important*)
globalParList={{Dx,0}};
(*In globalParSet are the values of the parameter sets.*)
globalParSet={{{2}}};


(*Multithreading loop: write as many input files as number of threads.*)
nParameterPerThread=1;
multiThreadingGlobalParIndicesTable=Partition[Range[Length[globalParSet]],nParameterPerThread];

(*globalPar is the list of rules of replacement.*)
globalPar=#[[1]]->#[[2]]&/@globalParList;
nGlobalParSet=Dimensions[globalParSet][[1]];

x0CellHeterogeneous=True;
x0CellChangingWithGlobalPar=False;
x0MilieuChangingWithGlobalPar=False;

(*Initial conditions have to be in number of molecules*)

If[x0CellChangingWithGlobalPar,
If[x0CellHeterogeneous
,
x0CellGeneralTable=Table[{
Join[
Table[Round[{1,10}/nmolesV1],{Floor[(nCells//.par)/2]}],
Table[Round[{10,1}/nmolesV1],{(nCells-Floor[nCells/2])//.par}]
],
Table[CForm[phaseV1],{nCells//.par}]
},{iGlobalPar,nGlobalParSet}];
,
x0CellGeneralTable=Table[
Round[{5,5}/nmolesV1//.par]
,{nGlobalParSet}];
];
,
If[x0CellHeterogeneous
,
(*We set half of the cells to the stable state 1 and the other half to the stable state 2.*)
x0CellHeterogeneousTable=Join[
Table[Round[{1,10}/nmolesV1//.par],{Floor[(nCells//.par)/2]}],
Table[Round[{10,1}/nmolesV1//.par],{(nCells-Floor[nCells/2])//.par}]
];
phase0CellHeterogeneousTable=Table[CForm[phaseV1],{nCells//.par}];
x0CellGeneralTable={x0CellHeterogeneousTable,phase0CellHeterogeneousTable};
,
x0CellGeneralTable=x0Cell;
];
];

x0Milieu={0,0};
If[x0MilieuChangingWithGlobalPar,
(*Add AIxAdded nM of autoinducer at the beginning*)
x0MilieuGeneralTable=Table[Round[x0Milieu/nmolesVext],{i,nGlobalParSet}];
,
x0MilieuGeneralTable=Round[x0Milieu/nmolesVext];
];

outputPath=path;
inputFilePath=inputFilePath;

,

"ExternalMagneticField"
,
(*Here we modify the par table to exclude the parameters that we want to change for the simulations.*)
par=Join[Select[par,#[[1]]=!=α1&&#[[1]]=!=α2&&#[[1]]=!=Dx&&#[[1]]=!=nCells&],{α1->αHzero+h,α2->αHzero,αHzero->α1/.par,Dx->1.0,nCells->10}];

simulationTime=10000;
timeMeshSliceLength=1;
nTrajectories=1;
changeTimeStepWithDiffusion=False;
simTimePoints={simulationTime};
nTimeStepsIntervalDisplaySimulationProgress=Round[simulationTime/timeMeshSliceLength/100];
(*In globalParList only the name of the parameters is important*)
globalParList={{h,0}};
(*In globalParSet are the values of the parameter sets.*)

(*Hysteresis simulation, we build a time mesh with h varying from -1 to +1 and back to -1 during the trajectory.*)
simTimePoints=N[Range[0,simulationTime,simulationTime/1000]];
globalParSet=
{
N[Partition[Join[Range[-1,1,2/((Length[simTimePoints]/2)-1)],Range[1,-1,-2/((Length[simTimePoints]/2)-1)],{-1}],1]]
};
Print["Length[simTimePoints] = ",Length[simTimePoints]," Length[globalParSet] = ",Length[globalParSet[[1]]]];

(*Multithreading loop: write as many input files as number of threads.*)
nParameterPerThread=1;
multiThreadingGlobalParIndicesTable=Partition[Range[Length[globalParSet]],nParameterPerThread];

(*globalPar is the list of rules of replacement.*)
globalPar=#[[1]]->#[[2]]&/@globalParList;
nGlobalParSet=Dimensions[globalParSet][[1]];

x0CellHeterogeneous=True;
x0CellChangingWithGlobalPar=False;
x0MilieuChangingWithGlobalPar=False;

(*Initial conditions have to be in number of molecules*)

If[x0CellChangingWithGlobalPar,
If[x0CellHeterogeneous
,
x0CellGeneralTable=Table[{
Join[
Table[Round[stableState1/nmolesV1],{Floor[(nCells//.par)/2]}],
Table[Round[stableState2/nmolesV1],{(nCells-Floor[nCells/2])//.par}]
],
Table[CForm[phaseV1],{nCells//.par}]
},{iGlobalPar,nGlobalParSet}];
,
x0CellGeneralTable=Table[
Round[{Random[Real,{aRandom,bRandom}],Random[Real,{aRandom,bRandom}]}/nmolesV1//.par]
,{nGlobalParSet}];
];
,
If[x0CellHeterogeneous
,
(*We set half of the cells to the stable state 1 and the other half to the stable state 2.*)
x0CellHeterogeneousTable=Join[
Table[Round[{10,1}/nmolesV1//.par],{Floor[(nCells//.par)/2]}],
Table[Round[{1,10}/nmolesV1//.par],{(nCells-Floor[nCells/2])//.par}]
](*Table[Round[stableState2/nmolesV1//.par],{nCells//.par}]*);
phase0CellHeterogeneousTable=Table[CForm[phaseV1],{nCells//.par}];
x0CellGeneralTable={x0CellHeterogeneousTable,phase0CellHeterogeneousTable};
,
x0CellGeneralTable=x0Cell;
];
];

x0Milieu={0,0};
If[x0MilieuChangingWithGlobalPar,
(*Add AIxAdded nM of autoinducer at the beginning*)
x0MilieuGeneralTable=Table[Round[x0Milieu/nmolesVext],{i,nGlobalParSet}];
,
x0MilieuGeneralTable=Round[x0Milieu/nmolesVext];
];

outputPath=path;
inputFilePath=inputFilePath;


]

Print["x0Cell initial condition (nb of molecules) = ",x0CellGeneralTable];
Print["x0Milieu initial condition (nb of molecules) = ",x0MilieuGeneralTable];
Print["globalParSet = ",globalParSet];
Print["# globalParSet = ",nGlobalParSet];
Print["Output path = \n",outputPath];
Print["Input file path = \n",inputFilePath];
Print["Parameters = \n",par];
Definition of the reaction probability rates (with diffusion process) and output to the C++ file
Write the input file with all the parameters and the definition of the system of reactions
Module[{write1DArray,write2DArray,threadID=0},
write1DArray[f1_,array1D_]:=Module[{},
If[ArrayDepth[array1D]!=1,
Print["ERROR, function write1DArray, the array has rank different from 1."];
,
Return[f1<>ToString[StringForm["``",Length[array1D]]]<>"\n[ "<>ToString[StringForm["``",TableForm[array1D,TableDirections->Row]]]<>" ]\n"];
];
];
write2DArray[f1_,array2D_]:=Module[{},
If[ArrayDepth[array2D]!=2,
Print["ERROR, function write2DArray, the array has rank different from 2."];
,
Return[f1<>ToString[StringForm["`` x ``",Dimensions[array2D][[1]],Dimensions[array2D][[2]]]]<>"\n[ "<>ToString[TableForm[array2D,TableSpacing->{0,1}]]<>" ]\n"];
];
];

(*Multithreading loop: write as many input files as number of threads.*)
Do[
threadID++;
iseed=Random[Integer,1000000];

SetDirectory[inputFilePath];
fpath="input.dat";DeleteFile[fpath];
fpath="input"<>intstring[threadID]<>".dat";DeleteFile[fpath];
Clear[f1];
f1="";
f1=f1<>"#Integer seed for the random number generator:\n";
f1=f1<>ToString[StringForm["``\n",
If[experiment=="TimeStepConvergence"&&nParameterPerThread==1,
(*In the time step convergence experiment, we want to keep the same seed in order to compare better the different results.*)
137
,
iseed
]
]];
f1=f1<>"#Output directory path:\n";
f1=f1<>ToString[StringForm["``\n",outputPath]];
f1=f1<>"#First passage time experiment: GFP threshold:\n";
f1=f1<>ToString[StringForm["``\n",firstPassageGFPThreshold]];
f1=f1<>"#First passage time experiment: Stop trajectory when cell passes above (0) or under (1) GFP threshold:\n";
f1=f1<>ToString[StringForm["``\n",Switch[jumpingDirection,"OffOn",0,"OnOff",1,_,0]]];
f1=f1<>"#Stop simulation when reaching maximum volume available, for example for unlimited growth (boolean):\n";
f1=f1<>ToString[StringForm["``\n",stopWhenReachingMaximumVolume]];
f1=f1<>"#Length of the time mesh slices (time interval) to average the trajectories:\n";
f1=f1<>ToString[StringForm["``\n",CForm[timeMeshSliceLength]]];
f1=f1<>"#Time step used in the Chemical Langevin algorithm:\n";
f1=f1<>ToString[StringForm["``\n",
CForm[
If[experiment=="TimeStepConvergence"&&nParameterPerThread==1,
globalParSet[[threadID,1,1]]
,
If[changeTimeStepWithDiffusion,
If[globalParSet[[threadID,1,1]]!=0,Min[1*^-3 1/globalParSet[[threadID,1,1]],1*^-4],1*^-3]
,
chemicalLangevinTimeStep
]
]
]
]];
f1=f1<>"#Boolean value: compute cells spatial dynamics (ODE simulation):\n";
f1=f1<>ToString[StringForm["``\n",Boole[computeSpatialDynamics]]];
f1=f1<>"#Equilibration time for the cells spatial dynamics (ODE simulation):\n";
f1=f1<>ToString[StringForm["``\n",spatialDynamicsEquilibrationTime]];
f1=f1<>"#Number of trajectories:\n";
f1=f1<>ToString[StringForm["``\n",nTrajectories]];
f1=f1<>"#Interval of time steps to display the ouput in the console:\n";
f1=f1<>ToString[StringForm["``\n",nTimeStepsIntervalDisplaySimulationProgress]];
f1=f1<>"#Simulation time points table:\n";
f1=f1<>ToString[StringForm["``",Length[simTimePoints]]]<>"\n[ "<>ToString[StringForm["``",TableForm[simTimePoints,TableDirections->Row]]]<>" ]\n";
f1=f1<>"#Global parameters name list:\n";
f1=f1<>ToString[StringForm["``\n",TableForm[globalParList[[All,1]],TableDirections->Row]]];
f1=f1<>"#Global parameters table. The first dimension correspond to the parameter sets (different simulation runs with different sets of parameter values). The second dimension correspond to the different values of the global parameters at defined time points in the simulation, so that global parameters can change as a step-like function with time at time points defined in the simulation time points table. The third dimension correspond to the global parameters themselves.\n";
f1=f1<>ToString[Dimensions[multiThreadingGlobalParIndicesTable][[2]] (*This is the number of parameters per thread*) ]<>" x "<>ToString[Dimensions[globalParSet[[ iThreadIndicesTable ]] ][[2]] ]<>" x "<>ToString[Dimensions[globalParSet[[ iThreadIndicesTable ]] ][[3]] ]<>"\n[\n";
Do[
Do[
f1=f1<>ToString[StringForm["``",TableForm[CForm/@iSet[[it]],TableDirections->Row]]]<>"\n";
,{it,Length[iSet]}];
,{iSet,globalParSet[[ iThreadIndicesTable ]]}];
f1=f1<>"]\n";
f1=f1<>"#Number of cells in colony:\n";
f1=f1<>ToString[StringForm["``\n",nCells//.par]];
f1=f1<>"#Boolean value: keep the cell density constant:\n";
f1=f1<>ToString[StringForm["``\n",Boole[constantCellDensity]]];
f1=f1<>"#Total volume of the system (cells + milieu) in micrometers cubic:\n";
f1=f1<>ToString[StringForm["``\n",
CForm[
If[experiment=="Volume"&&nParameterPerThread==1,
Vtot//.Select[par,#[[1]]=!=V0&]/.V0->globalParSet[[threadID,1,1]]
,
Vtot//.par
]
]
]];
f1=f1<>"#Volume of a cell in micrometers cubic:\n";
f1=f1<>ToString[StringForm["``\n",
CForm[
If[experiment=="Volume"&&nParameterPerThread==1,
globalParSet[[threadID,1,1]]
,
V0//.par
]
]
]];
f1=f1<>"#Initial length of a cell in micrometers:\n";
f1=f1<>ToString[StringForm["``\n",cellLength0//.par]];
f1=f1<>"#Initial height of a cell in micrometers:\n";
f1=f1<>ToString[StringForm["``\n",cellHeight0//.par]];
f1=f1<>"#Deterministic part of the cell cycle in minutes:\n";
f1=f1<>ToString[StringForm["``\n",cellCycleDeterministic]];
f1=f1<>"#Stochastic to deterministic weight parameter for the cell cycle distribution:\n";
f1=f1<>ToString[StringForm["``\n",cellCycleGamma]];
f1=f1<>"#List of the species name of the cells:\n";
f1=f1<>ToString[StringForm["``\n",TableForm[speciesCell,TableDirections->Row]]];
f1=f1<>"#Number of species in the cells:\n";
f1=f1<>ToString[StringForm["``\n",nSCell]];
f1=f1<>"#Number of reaction channels in the cells:\n";
f1=f1<>ToString[StringForm["``\n",2*nRCell]];
f1=f1<>"#x0 Cell is changing with global parameters set (boolean value):\n";
f1=f1<>ToString[StringForm["``\n",Boole[x0CellChangingWithGlobalPar]]];
f1=f1<>"#Heterogenous (1 or True) or homogenous (0 or False) initial conditions:\n";
f1=f1<>ToString[StringForm["``\n",Boole[x0CellHeterogeneous]]];
f1=f1<>"#List of initial conditions x0Cell. If initial conditions are changing with the global parameters set, then this is a list of nGlobalPar initial conditions. If the initial conditions are homogenous, then each initial condition is a vector of size nSpecies containing the number of molecules of each species (the same for all the cells). If the initial condition is heterogenous, then the initial condition is composed as follows: an 2D array of size nCells x nSpecies containing the number of molecules of every species in every cell, a vector of size nCells containing the initial phase of every cell.\n";

If[x0CellChangingWithGlobalPar
,
(*Multithreading*)
If[x0CellHeterogeneous
,
Do[
f1=write2DArray[f1,ix0[[1]]];(*x0CellHeterogeneousTable*)
f1=write1DArray[f1,ix0[[2]]];(*phase0CellHeterogeneousTable*)
,{ix0,x0CellGeneralTable[[ iThreadIndicesTable ]]}];
,
Do[
f1=write1DArray[f1,ix0];(*x0Cell*)
,{ix0,x0CellGeneralTable[[ iThreadIndicesTable ]]}];
];
,
(*No multithreading*)
If[x0CellHeterogeneous
,
f1=write2DArray[f1,x0CellGeneralTable[[1]]];(*x0CellHeterogeneousTable*)
f1=write1DArray[f1,x0CellGeneralTable[[2]]];(*phase0CellHeterogeneousTable*)
,
f1=write1DArray[f1,x0CellGeneralTable];(*x0Cell*)
];
];

f1=f1<>"#List of the species name of the milieu:\n";
f1=f1<>ToString[StringForm["``\n",TableForm[speciesMilieu,TableDirections->Row]]];
f1=f1<>"#Number of species in the milieu:\n";
f1=f1<>ToString[StringForm["``\n",nSMilieu]];
f1=f1<>"#Number of reaction channels in the milieu:\n";
f1=f1<>ToString[StringForm["``\n",2*nRMilieu]];
f1=f1<>"#x0 Milieu is changing with global parameters set (boolean value):\n";
f1=f1<>ToString[StringForm["``\n",Boole[x0MilieuChangingWithGlobalPar]]];
f1=f1<>"#List of initial conditions x0Milieu. If initial conditions are changing with the global parameters set, then this is a list of nGlobalPar vectors of initial condition:\n";

If[x0MilieuChangingWithGlobalPar
,
(*Multithreading*)
Do[
f1=write1DArray[f1,ix0];(*x0Milieu*)
,{ix0,x0MilieuGeneralTable[[ iThreadIndicesTable ]]}];
,
(*No multithreading*)
f1=write1DArray[f1,x0MilieuGeneralTable];(*x0Milieu*)
];

f1=f1<>"#DNA species in the cells. Array defining which are the genetic species, DNA and protein-DNA complexes:\n";
f1=f1<>ToString[Dimensions[dnaCell][[1]]]<>" x "<>ToString[Dimensions[dnaCell][[2]]]<>"\n[ ";
f1=StringInsert[f1,ToString[TableForm[dnaCell,TableSpacing->{0,1}]],-1];
f1=f1<>" ]\n";
f1=f1<>"#NV in cells. Stochiometric matrix of reactions in the cells:\n";
f1=f1<>ToString[Dimensions[NVCell][[1]]]<>" x "<>ToString[Dimensions[NVCell][[2]]]<>"\n[ ";
f1=StringInsert[f1,ToString[TableForm[NVCell,TableSpacing->{0,1}]],-1];
f1=f1<>" ]\n";
f1=f1<>"#Number of cell-milieu reaction channels:\n";
f1=f1<>ToString[StringForm["``\n",2*nRCellMilieu]];
f1=f1<>"#NV cell-milieu. Stochiometric matrix of cell-milieu reactions:\n";
f1=f1<>ToString[Dimensions[NVCellMilieu][[1]]]<>" x "<>ToString[Dimensions[NVCellMilieu][[2]]]<>"\n[ ";
f1=StringInsert[f1,ToString[TableForm[NVCellMilieu,TableSpacing->{0,1}]],-1];
f1=f1<>" ]\n";
f1=f1<>"#NV milieu. Stochiometric matrix of reactions in the milieu:\n";
f1=f1<>ToString[Dimensions[NVMilieu][[1]]]<>" x "<>ToString[Dimensions[NVMilieu][[2]]]<>"\n[ ";
f1=StringInsert[f1,ToString[TableForm[NVMilieu,TableSpacing->{0,1}]],-1];
f1=f1<>" ]\n\n";

Export[fpath,f1,"Text"];

,{iThreadIndicesTable,multiThreadingGlobalParIndicesTable}];
];
Write the C++ method computePropensitiesFunctions (Gillespie)
(****************************************************************)

SetDirectory[sourceDirectory];
fpath="computePropensitiesFunctions.cpp";Deletefile[fpath];
f2path="computePropensitiesFunctions.h";Deletefile[fpath2];
Clear[f1,f2];

globalParCppCode=MapIndexed[#1[[1]]->GB[#2[[1]]-1]&,globalParList];
Switch[experiment,
"Volume",
par1=Select[par,#[[1]]=!=V0&];
,
"Coupling",
par1=Select[par,#[[1]]=!=Dx&];
,
_,
par1=par;
];

f2="/***************************************************************************//**
 * Project: Colony
 *
 * \\file    computePropensitiesFunctions.h
 * \\author  Marc Weber\\n
 *          The Si.M.Bio.Sys. Group (CosmoLab)\\n
 *          Parc Cienti­fic de Barcelona\\n
 *          Barcelona, Spain.\\n
 *          http://thesimbiosys.isgreat.org
 * \\version 0.1
 * \\date    03/2009
 *
 *          Output file from Mathematica.\\n
 *          Copyright 2009 by Marc Weber
 ******************************************************************************/

#ifndef COMPUTEPROPENSITIESFUNCTIONS_CPP
#define COMPUTEPROPENSITIESFUNCTIONS_CPP

// libraries header files
#include <blitz/array.h>

// standard C++ header files
#include <iostream>

// libraries header files
#include <blitz/array.h>

// user header files
#include \"Input.h\"
#include \"RandomNumberGenerator.h\"

// namespaces
using blitz::Array;
using std::cout;
using std::endl;


";
f="/***************************************************************************//**
 * Project: Colony
 *
 * \\file    computePropensitiesFunctions.cpp
 * \\author  Marc Weber\\n
 *          The Si.M.Bio.Sys. Group (CosmoLab)\\n
 *          Parc Cienti­fic de Barcelona\\n
 *          Barcelona, Spain.\\n
 *          http://thesimbiosys.isgreat.org
 * \\version 0.1
 * \\date    03/2009
 *
 *          Output file from Mathematica.\\n
 *          Copyright 2009 by Marc Weber
 ******************************************************************************/

#include \"debug.h\"

#ifndef USE_CHEMICAL_LANGEVIN

#include \"computePropensitiesFunctions.h\"

";

(****************************************************************)

systemCell={speciesCell,nSCell,nRCell,NPCell,NMCell,cpCell,cmCell,reacCell,"computePropensitiesCell"};
systemMilieu={speciesMilieu,nSMilieu,nRMilieu,NPMilieu,NMMilieu,cpMilieu,cmMilieu,reacMilieu,"computePropensitiesMilieu"};
Do[
Module[{
species=system[[1]],
S=system[[2]],
R=system[[3]],
NP=system[[4]],
NM=system[[5]],
cp=system[[6]],
cm=system[[7]],
reac=system[[8]],
funcName=system[[9]],
ruleChangeSpeciesVariableNameInReactionRates},
Clear[x];
ap=Table[Part[reac,μ,3,1]N[cp[[μ]],15] 
UnderoverscriptBox[∏, i = 1, S]Product[(x[i - 1] - k), {k, 0, NP[[μ, i]] - 1}],{μ,R}]//.par1/.globalParCppCode;
ruleChangeSpeciesVariableNameInReactionRates=Thread[species->Table[x[i-1],{i,S}]];
ap=ap/.Thread[#[t]&/@species->species];
ap=ap/.ruleChangeSpeciesVariableNameInReactionRates;
Do[ap[[i]]=ToString[CForm[ap[[i]]]],{i,R}];
ap=StringReplace[ap,{"GB"->"Input::globalParameter","Power"->"pow"}];
ap=StringReplace[ap,"volumeMilieu"->ToString[Vext//.par1]];
am=Table[Part[reac,μ,3,2]N[cm[[μ]],15] 
UnderoverscriptBox[∏, i = 1, S]Product[(x[i - 1] - k), {k, 0, NM[[μ, i]] - 1}],{μ,R}]//.par1/.globalParCppCode;
am=am/.Thread[#[t]&/@species->species];
am=am/.ruleChangeSpeciesVariableNameInReactionRates;
Do[am[[i]]=ToString[CForm[am[[i]]]],{i,R}];
am=StringReplace[am,{"GB"->"Input::globalParameter","Power"->"pow"}];
f2=f2<>"void "<>funcName<>"
(
  const Array<int,1>& x,
  Array<double,1>& a
);\n\n\n";
f=f<>"void "<>funcName<>"
(
  const Array<int,1>& x,
  Array<double,1>& a
)
{
  #ifdef COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n"<>
ToString[StringForm["  if ( `` != a.size()) ",2*R]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x, propensities),\"
          \" array \\\"propensities\\\" does not have \"
          \"the same size as the number of reactions\";
  exit(1);
  }\n\n";
  f=f<>
ToString[StringForm["  if ( `` != x.size()) ",S]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x, propensities),\"
          \" array \\\"x\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n  #endif //COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n\n";
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1,ap[[ir]]]],-1],{ir,R}];
f=f<>"\n";
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1+R,am[[ir]]]],-1],{ir,R}];
f=f<>"\n\n  #ifdef COMPUTEPROPENSITIES_POSITIVITY_CHECK
  int i;
  for (i=0; i<"<>ToString[StringForm["``",2R]]<>"; i++)
  {
    if ( a(i) < 0.0 )
    {
      cout << \"WARNING: function "<>funcName<>"(x, propensities),\"
              \" negative propensity detected: a(\" << i << \") = \" << a(i)
           << \". Resetting a to 0.0\" << endl;
      a(i) = 0.0;
    }
  }
  #endif //COMPUTEPROPENSITIES_POSITIVITY_CHECK
}\n\n\n";
];
,{system,{systemCell,systemMilieu}}];

(****************************************************************)

(*TIME DEPENDENT CELL REACTIONS*)
Do[
Module[{
species=system[[1]],
S=system[[2]],
R=system[[3]],
NP=system[[4]],
NM=system[[5]],
cp=system[[6]],
cm=system[[7]],
reac=system[[8]],
funcName=system[[9]]<>"TimeDependent",
ruleChangeSpeciesVariableNameInReactionRates},
Clear[x];

(*WITH TIME DEPENDENT CORRECTION FOR SECOND-ORDER REACTIONS*)
ap=Table[Part[reac,μ,3,1]
Switch[Length[reac[[μ,1]]],
0,cp[[μ]]*(volume/volume0),
2,cp[[μ]]/(volume/volume0),
_,cp[[μ]]]

UnderoverscriptBox[∏, i = 1, S]Product[(x[i - 1] - k), {k, 0, NP[[μ, i]] - 1}],{μ,R}]//.par1/.globalParCppCode;
ruleChangeSpeciesVariableNameInReactionRates=Thread[species->Table[x[i-1],{i,S}]];
ap=ap/.Thread[#[t]&/@species->species];
ap=ap/.ruleChangeSpeciesVariableNameInReactionRates;
Do[ap[[i]]=ToString[CForm[ap[[i]]]],{i,R}];
ap=StringReplace[ap,{"GB"->"Input::globalParameter","Power"->"pow"}];
ap=StringReplace[ap,"volumeMilieu"->"volume"];

(*WITH TIME DEPENDENT CORRECTION FOR SECOND-ORDER REACTIONS*)
am=Table[Part[reac,μ,3,2]
Switch[Length[reac[[μ,2]]],
0,cm[[μ]]*(volume/volume0),
2,cm[[μ]]/(volume/volume0),
_,cm[[μ]]]
 
UnderoverscriptBox[∏, i = 1, S]Product[(x[i - 1] - k), {k, 0, NM[[μ, i]] - 1}],{μ,R}]//.par1/.globalParCppCode;
am=am/.Thread[#[t]&/@species->species];
am=am/.ruleChangeSpeciesVariableNameInReactionRates;
Do[am[[i]]=ToString[CForm[am[[i]]]],{i,R}];
am=StringReplace[am,{"GB"->"Input::globalParameter","Power"->"pow"}];
am=StringReplace[am,"volumeMilieu"->"volume"];

f2=f2<>"void "<>funcName<>"
(
  const Array<int,1>& x,
  const double volume,
  const double volume0,
  Array<double,1>& a
);\n\n\n";
f=f<>"void "<>funcName<>"
(
  const Array<int,1>& x,
  const double volume,
  const double volume0,
  Array<double,1>& a
)
{

";
f=f<>"
  #ifdef COMPUTEPROPENSITIES_TIME_CYCLE_CHECK
  if ( volume < 0.0 || volume > 2.0*volume0 )
  {
  cout << \"ERROR: function "<>funcName<>"(x, propensities),\"
          \" volume value is negative or bigger than the 2*V0.\";
  exit(1);
  }
  #endif //COMPUTEPROPENSITIES_TIME_CYCLE_CHECK

  #ifdef COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n"<>
ToString[StringForm["  if ( `` != a.size()) ",2*R]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x, propensities),\"
          \" array \\\"propensities\\\" does not have \"
          \"the same size as the number of reactions\";
  exit(1);
  }\n\n";
  f=f<>
ToString[StringForm["  if ( `` != x.size()) ",S]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x, propensities),\"
          \" array \\\"x\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n  #endif //COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n\n";

Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1,ap[[ir]]]],-1],{ir,R}];
f=f<>"\n";
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1+R,am[[ir]]]],-1],{ir,R}];

f=f<>"\n\n  #ifdef COMPUTEPROPENSITIES_POSITIVITY_CHECK
  int i;
  for (i=0; i<"<>ToString[StringForm["``",2R]]<>"; i++)
  {
    if ( a(i) < 0.0 )
    {
      cout << \"WARNING: function "<>funcName<>"(x, propensities),\"
              \" negative propensity detected: a(\" << i << \") = \" << a(i)
           << \". Resetting a to 0.0\" << endl;
      a(i) = 0.0;
    }
  }
  #endif //COMPUTEPROPENSITIES_POSITIVITY_CHECK
}\n\n\n";
];
,{system,{systemCell,systemMilieu}}]

(****************************************************************)

Module[{
species=species,
S=S,
S1=nSCell,
S2=nSMilieu,
R=nRCellMilieu,
NP=NPCellMilieu,
NP1=NPCellMilieu[[All,1;;nSCell]],
NP2=NPCellMilieu[[All,nSCell+1;;]],
NM=NMCellMilieu,
NM1=NMCellMilieu[[All,1;;nSCell]],
NM2=NMCellMilieu[[All,nSCell+1;;]],
funcName="computePropensitiesCellMilieu",
ruleChangeSpeciesVariableNameInReactionRates},
Clear[x,x1,x2];
ap=Table[Part[reacCellMilieu,μ,3,1]cpCellMilieu[[μ]] (
UnderoverscriptBox[∏, i = 1, S1]Product[(x1[i - 1] - k), {k, 0, NP1[[μ, i]] - 1}])(
UnderoverscriptBox[∏, i = 1, S2]Product[(x2[i - 1] - k), {k, 0, NP2[[μ, i]] - 1}]),{μ,R}]//.par1/.globalParCppCode;
ruleChangeSpeciesVariableNameInReactionRates=Thread[species->Table[x[i-1],{i,S}]];
ap=ap/.Thread[#[t]&/@species->species];
ap=ap/.ruleChangeSpeciesVariableNameInReactionRates;
Do[ap[[i]]=ToString[CForm[ap[[i]]]],{i,R}];
ap=StringReplace[ap,{"GB"->"Input::globalParameter","Power"->"pow"}];

am=Table[Part[reacCellMilieu,μ,3,2]cmCellMilieu[[μ]] (
UnderoverscriptBox[∏, i = 1, S1]Product[(x1[i - 1] - k), {k, 0, NM1[[μ, i]] - 1}])(
UnderoverscriptBox[∏, i = 1, S2]Product[(x2[i - 1] - k), {k, 0, NM2[[μ, i]] - 1}]),{μ,R}]//.par1/.globalParCppCode;
am=am/.Thread[#[t]&/@species->species];
am=am/.ruleChangeSpeciesVariableNameInReactionRates;

Do[am[[i]]=ToString[CForm[am[[i]]]],{i,R}];
am=StringReplace[am,{"GB"->"Input::globalParameter","Power"->"pow"}];

(*DIFFUSION TERM, VOLUME CORRECTION*)
am="(volume1/volume2)*"<>#&/@am;

f2=f2<>"void "<>funcName<>"
(
  const Array<int,1>& x1,
  const Array<int,1>& x2,
  const double volume1,
  const double volume2,
  Array<double,1>& a
);\n\n\n";
f=f<>"void "<>funcName<>"
(
  const Array<int,1>& x1,
  const Array<int,1>& x2,
  const double volume1,
  const double volume2,
  Array<double,1>& a
)
{
  #ifdef COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n"<>
ToString[StringForm["  if ( `` != a.size()) ",2*R]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"propensities\\\" does not have \"
          \"the same size as the number of reactions\";
  exit(1);
  }\n\n"<>
ToString[StringForm["  if ( `` != x1.size()) ",S1]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"x1\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n\n"<>
ToString[StringForm["  if ( `` != x2.size()) ",S2]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"x2\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n  #endif //COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n\n"
;
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1,ap[[ir]]]],-1],{ir,R}];
f=f<>"\n";
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1+R,am[[ir]]]],-1],{ir,R}];
f=f<>"\n\n  #ifdef COMPUTEPROPENSITIES_POSITIVITY_CHECK
  int i;
  for (i=0; i<"<>ToString[StringForm["``",2R]]<>"; i++)
  {
    if ( a(i) < 0.0 )
    {
      cout << \"WARNING: function "<>funcName<>"(x, propensities),\"
              \" negative propensity detected: a(\" << i << \") = \" << a(i)
           << \". Resetting a to 0.0\" << endl;
      a(i) = 0.0;
    }
  }
  #endif //COMPUTEPROPENSITIES_POSITIVITY_CHECK
}\n\n\n";
]
(****************************************************************)
In the deterministic equations, the diffusion rate is constant and is defined for the cells at their average volume V1. In the stochastic simulation, the cell volume and the cell area are growing, effectively changing the diffusion rate. The Fick's law reads D=P Σ, where P is the permeability of the membrane and Σ the cell area. We assume, for the sake of simplicity, that the cell area is proportional to the cell volume (e.g. valid in the case of an infinite cylinder),
D(t) = P Σ(t)=P Subscript[Σ, 1] V(t)/Subscript[V, 1]=Subscript[D, 1] V(t)/Subscript[V, 1]
where Subscript[D, 1] is the diffusion rate in the deterministic equations. The diffusion is defined as an emprirical law in the form of a deterministic equation,
Subscript[dc, A]/dt=D (Subscript[c, Aext]-Subscript[c, A])
which we translate into two stochastic reactions of diffusion into and out of the cell,
Overscript[Subscript[c, A], ·]=D Subscript[c, Aext]-D Subscript[c, A]
Overscript[A, ·]/V(t)=D Subscript[A, ext]/Subscript[V, ext]-D A/V(t)
Overscript[A, ·]=D Subscript[A, ext]/(Subscript[V, ext]/V(t))-D A
where D(t) is time dependent, D(t)=Subscript[D, 1]V(t)/Subscript[V, 1].
Module[{
species=species,
S=S,
S1=nSCell,
S2=nSMilieu,
R=nRCellMilieu,
NP=NPCellMilieu,
NP1=NPCellMilieu[[All,1;;nSCell]],
NP2=NPCellMilieu[[All,nSCell+1;;]],
NM=NMCellMilieu,
NM1=NMCellMilieu[[All,1;;nSCell]],
NM2=NMCellMilieu[[All,nSCell+1;;]],
funcName="computePropensitiesTimeDependentDiffusion",
ruleChangeSpeciesVariableNameInReactionRates},
Clear[x,x1,x2];

ap=Table[Part[reacCellMilieu,μ,3,1]cpCellMilieu[[μ]] (
UnderoverscriptBox[∏, i = 1, S1]Product[(x1[i - 1] - k), {k, 0, NP1[[μ, i]] - 1}])(
UnderoverscriptBox[∏, i = 1, S2]Product[(x2[i - 1] - k), {k, 0, NP2[[μ, i]] - 1}]),{μ,R}]//.par1/.globalParCppCode;

(*DIFFUSION TERM, TIME DEPENDENT VOLUME CORRECTION*)
ruleChangeSpeciesVariableNameInReactionRates=Thread[species->Table[x[i-1],{i,S}]];
ap=ap/.Thread[#[t]&/@species->species];
ap=ap/.ruleChangeSpeciesVariableNameInReactionRates;
Do[ap[[i]]=ToString[CForm[ap[[i]]]],{i,R}];

(*DIFFUSION TERM, VOLUME CORRECTION*)
ap=ToString[StringForm["(volume/(volume0/``))*",N[Log[2],15]]]<>#&/@ap;

ap=StringReplace[ap,{"GB"->"Input::globalParameter","Power"->"pow"}];

am=Table[Part[reacCellMilieu,μ,3,2]cmCellMilieu[[μ]] (
UnderoverscriptBox[∏, i = 1, S1]Product[(x1[i - 1] - k), {k, 0, NM1[[μ, i]] - 1}])(
UnderoverscriptBox[∏, i = 1, S2]Product[(x2[i - 1] - k), {k, 0, NM2[[μ, i]] - 1}]),{μ,R}]//.par1/.globalParCppCode;
am=am/.Thread[#[t]&/@species->species];
am=am/.ruleChangeSpeciesVariableNameInReactionRates;
Do[am[[i]]=ToString[CForm[am[[i]]]],{i,R}];
am=StringReplace[am,{"GB"->"Input::globalParameter","Power"->"pow"}];

(*DIFFUSION TERM, VOLUME CORRECTION*)
am="(volume/volumeExt)*"<>#&/@am;

f2=f2<>"void "<>funcName<>"
(
  const Array<int,1>& x1,
  const Array<int,1>& x2,
  const double volume,
  const double volume0,
  const double volumeExt,
  Array<double,1>& a
);\n\n\n";
f=f<>"void "<>funcName<>"
(
  const Array<int,1>& x1,
  const Array<int,1>& x2,
  const double volume,
  const double volume0,
  const double volumeExt,
  Array<double,1>& a
)
{
  /**
  * Time dependent propensities of diffusion reaction processes.
  *
  * We assume the cell to be a cylinder whose volume is growing exponentially,
  * with its radius constant.
  * The volume at the end of the cell cycle, \\f$ V(t_0+t_c) = 2V_0 \\f$, where
  * \\f$ V_0 \\f$ is the initial volume at the beginning of the cell cycle and
  * \\f$ t_0 \\f$ the time of the previous division event. The time evolution
  * of the volume writes
  * \\f[ V(t) = V_0 2^{\\frac{t-t_0}{tc}} \\f]
  *
  * We can calculate the evolution of the cell's surface area \\f$ \\Sigma(t) \\f$,
  * \\f[ \\Sigma(t) = \\Sigma_0 \\theta(t) \\f]
  * with
  * \\f[ \\theta(t) = 1 + \\frac{L_0}{L_0+r_0}\\left( 2^{\\frac{t-t_0}{tc}}-1 \\right) \\f]
  * where \\f$ L_0 \\f$ is the initial length of the cylinder and \\f$ r_0 \\f$ the
  * radius of the cylinder.
  *
  * However, for the sake of simplicity, we use the following approximation:
  * \\f[ \\theta(t) = V(t)/V_1 \\f]
  * where \\f$V_1\\f$ is the average of the cell volume during a cell cycle, i.e. for exponential growth is
  * \\f$ V1 = V_0/ln(2) \\f$
  *
  * The expression of the rates of reaction for the diffusion processes in and out
  * the cell, are given by
  * \\f[ k_{out}(t) = D_x \\theta(t) \\f]
  * \\f[ k_{in}(t) = D_x \\theta(t) \\frac{V(t)}{V_{ext}} \\f]
  * where we included \\f$ \\Sigma_0 \\f$ in the diffusion coefficient \\f$ D_x \\f$.
  *
  * @param x1 [in] %State vector of the cell.
  * @param x2 [in] %State vector of the milieu.
  * @param volume [in] Volume of the cell at time t.
  * @param volume0 [in] Volume of the cell at the beginning of the cell cycle (constant).
  * @param volumeExt [in] Volume of the external milieu at time t.
  * @param a [out] Array of the computed propensities.
  */\n\n";
(*
f=StringInsert[f,ToString[StringForm["  double L0 = ``;\n",L0//.par1]],-1];
f=StringInsert[f,ToString[StringForm["  double r0 = ``;\n",r0//.par1]],-1];
f=f<>"  double theta = 1.0 + (L0/(L0+r0))*(pow(2.0,(t-t0)/tc) - 1.0);
*)
f=f<>"
  #ifdef COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n"<>
ToString[StringForm["  if ( `` != a.size()) ",2*R]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"propensities\\\" does not have \"
          \"the same size as the number of reactions\";
  exit(1);
  }\n\n"<>
ToString[StringForm["  if ( `` != x1.size()) ",S1]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"x1\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n\n"<>
ToString[StringForm["  if ( `` != x2.size()) ",S2]]<>
"{
  cout << \"ERROR: function "<>funcName<>"(x1, x2, propensities),\"
          \" array \\\"x2\\\" does not have \"
          \"the same size as the number of species\";
  exit(1);
  }\n  #endif //COMPUTEPROPENSITIES_ARRAY_SIZE_CHECK\n\n"
;
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1,ap[[ir]]]],-1],{ir,R}];
f=f<>"\n";
Do[f=StringInsert[f,ToString[StringForm["  a(``) = ``;\n",ir-1+R,am[[ir]]]],-1],{ir,R}];
f=f<>"\n\n  #ifdef COMPUTEPROPENSITIES_POSITIVITY_CHECK
  int i;
  for (i=0; i<"<>ToString[StringForm["``",2R]]<>"; i++)
  {
    if ( a(i) < 0.0 )
    {
      cout << \"WARNING: function "<>funcName<>"(x, propensities),\"
              \" negative propensity detected: a(\" << i << \") = \" << a(i)
           << \". Resetting a to 0.0\" << endl;
      a(i) = 0.0;
    }
  }
  #endif //COMPUTEPROPENSITIES_POSITIVITY_CHECK
}\n\n\n";
]

f=f<>"#endif // USE_CHEMICAL_LANGEVIN\n";
f2=f2<>"
#endif // COMPUTEPROPENSITIESFUNCTIONS_CPP\n\n";
Export[fpath,f,"Text"];
Export[f2path,f2,"Text"];

x=Join[xCell,xMilieu];
Write the C++ method chemicalLangevinComputeIncrement with negative correction
changeAlphaBetaFunctionOfDiffusionRate=False;
globalParCppCode=MapIndexed[#1[[1]]->GB[#2[[1]]-1]&,globalParList];
SetDirectory[sourceDirectory];
fpath="chemicalLangevinComputeIncrement.cpp";
f2path="chemicalLangevinComputeIncrement.h";
f2="/***************************************************************************//**
 * Project: Colony
 *
 * \\file    chemicalLangevinComputeIncrement.h
 * \\author  Marc Weber\\n
 *          The Si.M.Bio.Sys. Group (CosmoLab)\\n
 *          Parc Cienti­fic de Barcelona\\n
 *          Barcelona, Spain.\\n
 * \\version 0.1
 * \\date    04/2012
 *
 *          Output file from Mathematica.\\n
 *          Copyright 2009 by Marc Weber
 ******************************************************************************/

#ifndef CHEMICALLANGEVINCOMPUTEINCREMENT_H
#define CHEMICALLANGEVINCOMPUTEINCREMENT_H

extern \"C\"
{
   #include <cblas.h>
}

// standard C++ header files
#include <iostream>

// libraries header files
#include <blitz/array.h>

// user header files
#include \"Input.h\"
#include \"RandomNumberGenerator.h\"

// namespaces
using blitz::Array;
using blitz::Range;
using std::cout;
using std::endl;

/**
  * Algorithm of Euler for the chemical Langevin equation.
  * This class is written by the mathematica notebook.
  */
class ChemicalLangevinComputeIncrement
{
public:

  ChemicalLangevinComputeIncrement();
  ~ChemicalLangevinComputeIncrement();

";
f="/***************************************************************************//**
 * Project: Colony
 *
 * \\file    chemicalLangevinComputeIncrement.cpp
 * \\author  Marc Weber\\n
 *          The Si.M.Bio.Sys. Group (CosmoLab)\\n
 *          Parc Cienti­fic de Barcelona\\n
 *          Barcelona, Spain.\\n
 * \\version 0.1
 * \\date    04/2012
 *
 *          Output file from Mathematica.\\n
 *          Copyright 2009 by Marc Weber
 ******************************************************************************/

#include \"debug.h\"

#ifdef USE_CHEMICAL_LANGEVIN

#include \"chemicalLangevinComputeIncrement.h\"

//------------------------------------------------------------------------------

ChemicalLangevinComputeIncrement::ChemicalLangevinComputeIncrement()
{
";
f=f<>ToString[StringForm["  nSCell = ``;\n",CForm[nSCell]]];
f=f<>ToString[StringForm["  nSMilieu = ``;\n",CForm[nSMilieu]]];
f=f<>ToString[StringForm["  nRCell = ``;\n",CForm[2*nRCell]]];
f=f<>ToString[StringForm["  nRMilieu = ``;\n",CForm[2*nRMilieu]]];
f=f<>ToString[StringForm["  nRCellMilieu = ``;\n",CForm[2*nRCellMilieu]]];
If[experiment=="coupling",
f=f<>"
  // Small optimization: as the square root of the diffusion reaction rate will appear
  // in many values of the bNoise matrix, we compute it here and replace it
  // in the bNoise assignments.
  // Note: this optimization would be probably done by the compiler.
";
f=f<>ToString[StringForm["  sqrtDx = sqrt(``);\n",CForm[Dx//.par]]];
];
f=f<>"
  // Conversion coefficient between number of molecules and concentration in nM.
";
f=f<>ToString[StringForm["  nMConversion = ``;\n",CForm[1*^9/6.02214*^23  *1/1*^-15]]];
f=f<>"  nMConversionPower3 = pow(nMConversion,3);\n";
f=f<>"
}

//------------------------------------------------------------------------------

ChemicalLangevinComputeIncrement::~ChemicalLangevinComputeIncrement()
{}

//------------------------------------------------------------------------------

void ChemicalLangevinComputeIncrement::setFixedNCells(int nCells)
{
  nSCellstot = nCells*nSCell;
  nRtot = 2.*(nCells*(nRCell+nRCellMilieu) + nRMilieu);
  nStot = nCells*nSCell + nSMilieu;

  bNoise.resize(nStot,nRtot);
  bNoise = 0.;

  noiseIncrementVector.resize(nStot);
}

//------------------------------------------------------------------------------

";

(****************************************************************)

Module[{
funcName="chemicalLangevinComputeIncrement"},

f2=f2<>"void "<>funcName<>"
(
  Array<double,1>& xConcCells,
  Array<double,1>& xConcMilieu,
  const int nCells,
  const double volumeCell,
  const double volumeExt,
  const double chemicalLangevinTimeStep
);

";
f=f<>"void ChemicalLangevinComputeIncrement::"<>funcName<>"
(
  Array<double,1>& xConcCells,
  Array<double,1>& xConcMilieu,
  const int nCells,
  const double volumeCell,
  const double volumeExt,
  const double chemicalLangevinTimeStep
)
{\n\n";

f=f<>"  int nSCellstot = nCells*nSCell;\n";
f=f<>"  nRtot = 2.*(nCells*(nRCell+nRCellMilieu) + nRMilieu);\n";
f=f<>"  nStot = nCells*nSCell + nSMilieu;\n";
f=f<>"  double sqrtTimeStep = sqrt(chemicalLangevinTimeStep);\n";


f=f<>"
  // Computing the population average of U and V
";
f=f<>ToString[StringForm["  //double avgU = mean( xConcCells( blitz::Range( ``, blitz::toEnd, nSCell ) ) );\n",pos[U,speciesCell]-1]];
f=f<>ToString[StringForm["  //double avgV = mean( xConcCells( blitz::Range( ``, blitz::toEnd, nSCell ) ) );\n",pos[V,speciesCell]-1]];

If[changeAlphaBetaFunctionOfDiffusionRate,
f=f<>"
 
 // Computing the expression of alpha and beta in function of the diffusion coefficient D
";
f=f<>StringReplace[ToString[StringForm["  double alpha = ``;\n",ToString[CForm[α1//.par]/.globalParCppCode]]],{"Power"->"pow"}];
f=f<>StringReplace[ToString[StringForm["  double beta = ``;\n",ToString[CForm[β1//.par]/.globalParCppCode]]],{"Power"->"pow"}];
];

f=f<>"
 

 // Computing deterministic increments

  // Compute increments for cell species
  for (int iCell=0; iCell<nCells; iCell++)
  {
";

Do[
f=f<>
ToString[StringForm["    xConcCells(iCell*nSCell + ``) += (",iEqu-1]]<>
StringReplace[
StringReplace[ToString[CForm[N[equ[[iEqu,2]]/.If[changeAlphaBetaFunctionOfDiffusionRate,{α1->alpha,α2->alpha,β1->beta,β2->beta},{}]//.par]/.globalParCppCode]],
Join[{"Power"->"pow"},
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcCells(``)",CForm[iCell*nSCell+pos[iS,speciesCell]-1]]],{iS,speciesCell}],
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcMilieu(``)",CForm[pos[iS,speciesMilieu]-1]]],{iS,speciesMilieu}]
]]
,"pow("~~xy__~~",3)":>xy<>"*"<>xy<>"*"<>xy]
<>") * chemicalLangevinTimeStep;\n";
,{iEqu,nSCell}];
f=f<>"  }\n";

f=f<>"
  // Compute increments for milieu species. We need to compute separately the increments
  // for the milieu reactions and for the cell-milieu reactions, which will be corrected for volume effects.

  // Compute increments for milieu species for milieu reactions.
";

(*Computing deterministic terms for milieu reactions.*)
prod[x_]:=Product[x[[i]],{i,Length[x]}]/.Table[species[[i]]->species[[i]][t],{i,S}];
equfill=Table[0,{nSMilieu}];
Do[Do[
equfill[[i]]+=-Part[reacMilieu,j,3,1]NPMilieu[[j]][[i]]kpMilieu[[j]]prod[Part[reacMilieu,j,1]]+Part[reacMilieu,j,3,2]NPMilieu[[j]][[i]]kmMilieu[[j]]prod[Part[reacMilieu,j,2]];
equfill[[i]]+=+Part[reacMilieu,j,3,1]NMMilieu[[j]][[i]]kpMilieu[[j]]prod[Part[reacMilieu,j,1]]-Part[reacMilieu,j,3,2]NMMilieu[[j]][[i]]kmMilieu[[j]]prod[Part[reacMilieu,j,2]];
,{i,nSMilieu}],{j,nRMilieu}];
Do[
f=f<>
ToString[StringForm["  xConcMilieu(``) += (",iEqu-1]]<>
StringReplace[
StringReplace[ToString[CForm[N[equfill[[iEqu]]//.par]/.globalParCppCode]],
Join[{"Power"->"pow"},
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcCells(``)",CForm[iCell*nSCell+pos[iS,speciesCell]-1]]],{iS,speciesCell}],
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcMilieu(``)",CForm[pos[iS,speciesMilieu]-1]]],{iS,speciesMilieu}]
]]
,"pow("~~xy__~~",3)":>xy<>"*"<>xy<>"*"<>xy]
<>") * chemicalLangevinTimeStep;\n";
,{iEqu,nSMilieu}];

f=f<>"
  // Compute increments for milieu species for cell-milieu reactions.
  for (int iCell=0; iCell<nCells; iCell++)
  {
";

prod[x_]:=Product[x[[i]],{i,Length[x]}]/.Table[species[[i]]->species[[i]][t],{i,S}];
equfill=Table[0,{S}];
Do[Do[
equfill[[i]]+=-Part[reac,j,3,1]NP[[j]][[i]]kp[[j]]prod[Part[reac,j,1]]+Part[reac,j,3,2]NP[[j]][[i]]km[[j]]prod[Part[reac,j,2]];
equfill[[i]]+=+Part[reac,j,3,1]NM[[j]][[i]]kp[[j]]prod[Part[reac,j,1]]-Part[reac,j,3,2]NM[[j]][[i]]km[[j]]prod[Part[reac,j,2]];
,{i,S}],{j,-nRCellMilieu,-1}];
equfill=equfill[[-nSMilieu;;-1]]/.Dx->Dx volumesVectori/volumeExt;

Do[
f=f<>
ToString[StringForm["    xConcMilieu(``) += (",iEqu-1]]<>
StringReplace[
StringReplace[ToString[CForm[N[equfill[[iEqu]]//.par]/.globalParCppCode]],
Join[{"Power"->"pow","volumesVectori"->(*"volumesVector(iCell)"*)"volumeCell"},
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcCells(``)",CForm[iCell*nSCell+pos[iS,speciesCell]-1]]],{iS,speciesCell}],
Table[ToString[iS]<>"(t)"->ToString[StringForm["xConcMilieu(``)",CForm[pos[iS,speciesMilieu]-1]]],{iS,speciesMilieu}]
]]
,"pow("~~xy__~~",3)":>xy<>"*"<>xy<>"*"<>xy]
<>") * chemicalLangevinTimeStep;\n";
,{iEqu,nSMilieu}];

f=f<>"  }



  // Computing stochastic increments

";

f=f<>"
  // Compute Bnoise matrix\n";
f=f<>ToString[StringForm["  //double noiseTermDAvgU = sqrt(avgU*``);\n",CForm[Dlattice//.par/.globalParCppCode]]];
f=f<>ToString[StringForm["  //double noiseTermDAvgV = sqrt(avgV*``);\n\n",CForm[Dlattice//.par/.globalParCppCode]]];


nRtot=2*((nCells//.par)*(nRCell+nRCellMilieu)+nRMilieu);
nStot=(nCells//.par)*nSCell+nSMilieu;
Do[
If[(Bnoise[[iiS,jjR]]//.par)=!=0&&(Bnoise[[iiS,jjR]]//.par)=!=0.,
f=f<>ToString[StringForm["  bNoise(``,``) = ",iiS-1,jjR-1]]<>
StringReplace[StringReplace[StringReplace[ToString[
CForm[N[Bnoise[[iiS,jjR]]/.{V0->volumeCell}/.If[changeAlphaBetaFunctionOfDiffusionRate,{α1->alpha,α2->alpha,β1->beta,β2->beta},{}]//.par]
/.globalParCppCode/.Flatten[Join[
Table[Table[iS[N[iCell]][t]->xConcCells[(iCell-1)*nSCell+pos[iS,speciesCell]-1],{iS,speciesCell}],{iCell,nCells//.par}],Table[iS[t]->xConcMilieu[pos[iS,speciesMilieu]-1],{iS,speciesMilieu}],
{avgU->avgU,avgV->avgV}
]]]],
{"Power"->"pow","Sqrt"->"sqrt"}],
{ToString[StringForm["sqrt(``)",CForm[Dx//.par]]]->"sqrtDx","sqrt(avgU*GB(0))"->"noiseTermDAvgU","sqrt(avgV*GB(0))"->"noiseTermDAvgV","pow(nMConversion,3)"->"nMConversionPower3"}],
{"pow("~~xy__~~",3)":>xy<>"*"<>xy<>"*"<>xy}]
<>";\n"];
,{iiS,nStot},{jjR,nRtot}];

f=f<>"

  // DoWhile loop with condition on positive values of xConc
  bool thereIsANegativeValue = false;
  do 
  {

    // Generating a vector of nRtot gaussian normal random numbers
    Array<double,1> randomGaussianVector(nRtot);
    for (int i=0; i<nRtot; i++)
    {
      randomGaussianVector(i) = RandomNumberGenerator::getNormal();
    }

    // Compute the matrix-vector product noiseIncrementVector = BNoise * randomGaussianVector.
    // BLAS matrix-vector multiplication
    // Note: We use the optimized BLAS library from ATLAS
    // (Automatically Tuned Linear Algebra Software) which is
    // architecture-specific.
    // See http://math-atlas.sourceforge.net/

    const int m = bNoise.extent(blitz::firstDim);
    const int n = bNoise.extent(blitz::secondDim);
    const double alphaBLAS = 1.0;
    const double betaBLAS = 0.0;
    const double *bNoisePointer = bNoise.data();
    double *noiseIncrementVectorPointer = noiseIncrementVector.data();
    const double *randomGaussianVectorPointer = randomGaussianVector.data();
    const int lda = n;
    const int incX = 1;
    const int incY = 1;

    cblas_dgemv(CblasRowMajor,CblasNoTrans,m,n,alphaBLAS,bNoisePointer,lda,
                randomGaussianVectorPointer,incX,betaBLAS,
                noiseIncrementVectorPointer,incY);


    // Compute if the stochastic increment would result in a negative value of xConc
    thereIsANegativeValue = any( 
      xConcCells + (sqrt(nMConversion/volumeCell))*noiseIncrementVector(Range(0,nSCellstot-1))*sqrtTimeStep < 0 )
      || 
      any( xConcMilieu  + (sqrt(nMConversion/volumeExt))*noiseIncrementVector(Range(nSCellstot,nStot-1))*sqrtTimeStep < 0 );

    if(thereIsANegativeValue) nbStepsWithNegativeCondition_ = nbStepsWithNegativeCondition_ + 1.0;
    totalNumberSteps_ = totalNumberSteps_ + 1.0;
  
  } while (thereIsANegativeValue);

  // Now that we know that the stochastic increment does not lead to a negative value, we apply the increment.
  xConcCells += (sqrt(nMConversion/volumeCell))*noiseIncrementVector(Range(0,nSCellstot-1))*sqrtTimeStep;
  xConcMilieu += (sqrt(nMConversion/volumeExt))*noiseIncrementVector(Range(nSCellstot,nStot-1))*sqrtTimeStep;

  proportionNegativeSteps = nbStepsWithNegativeCondition_ / totalNumberSteps_;
";

f=f<>"
}

#endif // USE_CHEMICAL_LANGEVIN
";
];
f=StringReplace[f,{"GB"->"Input::globalParameter"}];

f2=f2<>"
  void setFixedNCells(int nCells);
  double proportionNegativeSteps;


private:

  Array<double,2> bNoise;
  Array<double,1> noiseIncrementVector;
  int nSCell;
  int nSMilieu;
  int nRCell;
  int nRMilieu;
  int nRCellMilieu;
  int nSCellstot;
  int nRtot;
  int nStot;
  double nMConversion;
  double nMConversionPower3;
  double sqrtDx;
  double sqrtTimeStep;

  double totalNumberSteps_;
  double nbStepsWithNegativeCondition_;
";
f2=f2<>"
};

#endif // CHEMICALLANGEVINCOMPUTEINCREMENT_H
";

f;
f2;
Export[fpath,f,"Text"];
Export[f2path,f2,"Text"];
Code compilation
Compile C++ project with QtCreator. The different libraries needed for compilation are listed in COLONY.pro project file at the line beginning with LIBS += and also some headers at line INCLUDEPATH +=. For compiling the code without the GUI, i.e. without defining the GUI option in debug.h, one needs the following libraries:
Blitz++ version 0.9, a fast implementation of arrays in C++. website. This one is used throughout the code to define arrays.
Boost system and Boost filesystem, version 1.48, for handling files for output. website. Used in the Output class.
GSL library, version 1.15,the GNU scientific library, website. Used in the random number generator, class RandomNumberGenerator.
ODE library, Open Dynamics Engine, version 0.11. website. Used in the computation of the spatial movement of the cells in the growing colony. Even if the GUI option is not set, the spatial dynamics of the cells can still be computed. This can be chosen from an option in the input file, but I think that even if desactivated in the input file, we still need the library to compile the code.
libstdc++, additional runtime library for C++ compiled with the GNU compiler. version 4.6.3.
QT xml package. Add the option QT += xml in the project file COLONY.pro. Used for ???.
ATLAS library, optimized BLAS library from ATLAS (Automatically Tuned Linear Algebra Software) which is architecture-specific. website. Used in the matrix-vector multiplication in the Langevin algorithm. Speed up 1000x this computation step. This library has to be compiled for each architecture/machine, and result in optimized ATLAS, CBLAS and LAPACK libraries. GFORTRAN and f77BLAS seem to be needed also.
In addition to the libraries above, one also needs additional libraries when compiling the GUI:
HAS BEEN DELETED. qglviewer-qt4, an openGL 3D viewer library based on Qt. version 2.3.4. website. Used in the 3D visualization of the cell colony in the GUI. Depends on a bunch of libraries, as GLU, GLUT, and the OPENGL and XML Qt packages. 
For more information see the lab notebook page.
Important options can be set before compilation in the debug.h file. The most important option is to choose between fixed cell volume simulation and growing and dividing cell simulation, reflected in the option "TIME_DEPENDENT_PROPENSITIES".
Copy executable in the directory inputFilePath.
The executable can be run with an individual input file, or one can use the multithreading script, which will run as many threads as input files in the same directory.
Output will be written in the directory outputPath.
Results
The output files contain all the information of the trajectory of the chemical species concentrations, volume, position of every cell.
There are mainly two different kinds of simulations: fixed cell volume, or growing and dividing colony.
For the fixed cell volume, we can just read the data table, easy.
For the growing and dividing colony, we need to reconstruct the trajectory of individual cells from the data table and the genealogy information file. For reasons of data optimization, the data table when the colony is growing has the same simple structure with a varying number of cells at each line of data, but we cannot track the cell identity along the time course of the simulation. We need the information in the genealogy file to identify cells and to follow individual cell trajectories.
Analyse data functions
Some definitions of methods to extract simulation data from the data table. Note: using these definitions is more general because if something changes in the data structure we can just change it here, however, Mathematica is quite slow with using these methods, and it is much faster to extract directly elements from the data table.
extractTime[simCellsTraj_,it_]:=simCellsTraj[[it,3]];
extractNCells[simCellsTraj_,it_]:=simCellsTraj[[it,2]];
extractMaxNCells[simCellsTraj_]:=Max[Table[extractNCells[simCellsTraj,it],{it,Length[simCellsTraj]}]];
extractX[simCellsTraj_,species_,it_,iCell_:1]:=simCellsTraj[[it,
If[MemberQ[speciesMilieu,species],
3+pos[species,speciesMilieu],
(iCell-1)*nSCell+3+nSMilieu+pos[species,speciesCell]]
]];
extractTimeX[simCellsTraj_,species_,it_,jt_,iCell_]:=simCellsTraj[[it;;jt,
{3,
If[MemberQ[speciesMilieu,species],
3+pos[species,speciesMilieu],
(iCell-1)*nSCell+3+nSMilieu+pos[species,speciesCell]]
}
]];
extractTimeXAllSpecies[simCellsTraj_,it_,jt_,iCell_]:=simCellsTraj[[it;;jt,
Join[{3,3+pos[AIx,speciesMilieu]},
Table[(iCell-1)*nSCell+3+nSMilieu+pos[iSpecies,speciesCell],{iSpecies,speciesCell}]]
]];
extractAIx[simCellsTraj_,it_]:=simCellsTraj[[it,4]];
extractTimeNCells[simCellsTraj_]:=Table[{extractTime[simCellsTraj,it],extractNCells[simCellsTraj,it]},{it,Length[simCellsTraj]}];
extractTimeXList[simCellsTraj_,speciesList_,iCell_:1]:=
Table[
Table[{extractTime[simCellsTraj,it],extractX[simCellsTraj,iSpecies,it,iCell]},{it,Length[simCellsTraj]}]
,{iSpecies,speciesList}];
extractTimeAIx[simCellsTraj_]:=
Table[{extractTime[simCellsTraj,it],extractAIx[simCellsTraj,it]},{it,Length[simCellsTraj]}];
extractTimeXListConc[simCellsTraj_,simCellsTrajVolumes_,speciesList_,iCell_:1]:=
Table[Table[
{extractTime[simCellsTraj,it],extractX[simCellsTraj,iSpecies,it,iCell]/simCellsTrajVolumes[[it,3+iCell]]*nmolesV0*V0}
,{it,Length[simCellsTraj]}],{iSpecies,speciesList}];
extractTimeXListCellsAvg[simCellsTraj_,speciesList_]:=
Table[Table[
{extractTime[simCellsTraj,it],
Total[Table[extractX[simCellsTraj,iSpecies,it,iCell],{iCell,extractNCells[simCellsTraj,it]}]]/extractNCells[simCellsTraj,it]
}
,{it,Length[simCellsTraj]}],{iSpecies,speciesList}];
extractTimeXListConcCellsAvg[simCellsTraj_,simCellsTrajVolumes_,speciesList_]:=
Table[Table[
{extractTime[simCellsTraj,it],
Total[Table[extractX[simCellsTraj,iSpecies,it,iCell],{iCell,extractNCells[simCellsTraj,it]}]]/Total[simCellsTrajVolumes[[it,4;;-1]]]*nmolesV0*V0
}
,{it,Length[simCellsTraj]}],{iSpecies,speciesList}];
extractTimeAIxConc[simCellsTraj_]:=
Table[{extractTime[simCellsTraj,it],extractAIx[simCellsTraj,it]/(Vext//.par)*nmolesV0*V0},{it,Length[simCellsTraj]}];
extractTimeXListConcTrajCellsAvg[simCellsSampleAllTraj_,simCellsTrajVolumes_,speciesList_]:=
(*Average between the trajectories the concentration averaged over the cells. Problem: the length of each trajectory is different between cell divisions add time points to the trajectory and are random.*)
Module[{tMin,table},
tMin=Floor[Min[simCellsSampleAllTraj[[All,-1,3]]]/timeMeshSliceLength]*timeMeshSliceLength;Print[tMin];
table={};
Do[
table=Append[table,
Sum[
Select[
If[speciesList[[iS]]===AIx,
Print[iTraj," AIx"];
extractTimeAIxConc[simCellsSampleAllTraj[[iTraj]]],
Print[iTraj," ",speciesList[[iS]]];
extractTimeXListConcCellsAvg[simCellsSampleAllTraj[[iTraj]],simCellsTrajVolumes[[iTraj]],{speciesList[[iS]]}][[1]]
]
,Mod[#[[1]],timeMeshSliceLength]==0&]
,{iTraj,Length[simCellsSampleAllTraj]}]/Length[simCellsSampleAllTraj]
];
,{iS,Length[speciesList]}];
table
];

extractHistogramData[simCellsSampleAllTraj_,iTraj_:0]:=
Module[{tMax,aTraj,bTraj,tableiS,table,trajData},

tMax=Floor[Min[simCellsSampleAllTraj[[All,-1,3]]]/timeMeshSliceLength]*timeMeshSliceLength;
table={};

If[iTraj==0,
aTraj=1;bTraj=Dimensions[simCellsSampleAllTraj][[1]];,
aTraj=iTraj;bTraj=iTraj;];

Do[

If[iSpecies===GFP,
Do[
trajData=
Table[
Join[
{extractTime[simCellsSampleAllTraj[[jTraj]],it]},
Table[extractX[simCellsSampleAllTraj[[jTraj]],iSpecies,it,iCell]
,{iCell,extractNCells[simCellsSampleAllTraj[[jTraj]],it]}]
]
,{it,Length[simCellsSampleAllTraj[[jTraj]]]}];
trajData=Select[trajData,(FractionalPart[#[[1]]/timeMeshSliceLength]<1*^-15&&#[[1]]<=tMax)&];

If[jTraj==1,
tableiS=trajData,
tableiS=Join[tableiS,Drop[trajData,None,1],2];
];
Print["Function extractHistogramData, Traj. ",jTraj,"/",bTraj," species: ",iSpecies];
,{jTraj,aTraj,bTraj}];
,
tableiS={};
];

table=Join[table,{tableiS}];

,{iSpecies,DeleteCases[species,AIx]}];

table
];

extractHistogramDataGFPAIx[simCellsSampleAllTraj_,iTraj_:0]:=
Module[{tMax,aTraj,bTraj,table,trajData},

tMax=Floor[Min[simCellsSampleAllTraj[[All,-1,3]]]/timeMeshSliceLength]*timeMeshSliceLength;
table={};

If[iTraj==0,
aTraj=1;bTraj=Dimensions[simCellsSampleAllTraj][[1]];,
aTraj=iTraj;bTraj=iTraj;];

Do[
trajData=
Table[
Join[
{{extractTime[simCellsSampleAllTraj[[jTraj]],it]}},
{{extractAIx[simCellsSampleAllTraj[[jTraj]],it]}},
{Table[extractX[simCellsSampleAllTraj[[jTraj]],GFP,it,iCell]
,{iCell,extractNCells[simCellsSampleAllTraj[[jTraj]],it]}]}
]
,{it,Length[simCellsSampleAllTraj[[jTraj]]]}];
trajData=Select[trajData,(FractionalPart[#[[1,1]]/timeMeshSliceLength]<1*^-15&&#[[1,1]]<=tMax)&];

If[jTraj==1,
table=trajData;,
table=Join[table,trajData];
];
Print["Function extractHistogramDataGFPAIx, Traj. ",jTraj,"/",bTraj];
,{jTraj,aTraj,bTraj}];

table
];
extractPosition[simPos_,it_,iCell_]:=simPos[[it,3+(iCell-1)*2+{1,2}]];
extractVolume[simVol_,it_,iCell_]:=simVol[[it,3+(iCell-1)+1]];
extractAngle[simAngle_,it_,iCell_]:=simAngle[[it,3+(iCell-1)+1]];
computeCellTraj[jCell_]:=Module[{iCell=jCell,cellTraj={},simData=simDataXConc[[1]],simLineage=simDataLineage[[1]],end=False,iLineageEvent,nLineageEvent,it,jt,newCellIndexList},
it=1;jt=1;
iLineageEvent=2;
nLineageEvent=Length[simLineage];

While[!end,

If[simLineage[[iLineageEvent,1]]!=simLineage[[iLineageEvent-1,1]],
jt=it+-1+LengthWhile[simData[[it;;-1]],#[[3]]<simLineage[[iLineageEvent,1]]&];
(*Print["it = ",it," jt = ",jt, " next lineage event = ",simLineage[[iLineageEvent,1]]];
Print["appending cellTraj: ",extractTimeX[simData,GFP,it,jt,iCell]];*)
cellTraj=Join[cellTraj,extractTimeX[simData,GFP,it,jt,iCell]];
it=jt+1;
];
(*Find the new index of the cell*)
(*Here we always follow the MOTHER cell, i.e. the cell with the lowest index, which does not change index when dividing (it is easier then, we do not have to change index when cell divides).*)
(*Cell index start at 0 in the cellLineage file.*)
newCellIndexList=Pick[Range[Length[simLineage[[iLineageEvent,4;;-1]]]],simLineage[[iLineageEvent,4;;-1]],iCell-1];
(*If the cell number is not in the list, then cell has been removed, End up trajectory at this point.*)
If[Length[newCellIndexList]==0,end=True;,iCell=newCellIndexList[[1]];];
(*Print["new iCell = ",iCell];*)
iLineageEvent++;
];
cellTraj
];
Fixed cell number
Definition of plotting functions
Clear[plotsim,plotdetsim,plotSimCellTraj];
plotsim[species_,sim_,xConc_,iCell_,iTraj_,opts:OptionsPattern[]]:=
ListPlot[
If[iCell==0,
extractTimeXListCellsAvg[sim[[iTraj]],{species}],
extractTimeXList[sim[[iTraj]],{species},iCell]
]
,
PlotRange->All,Joined->True,InterpolationOrder->0,Mesh->Full,MeshStyle->None,AxesOrigin->{0,0},ImageSize->imagesize,AxesLabel->{"t [min]",ToString[species]<>If[xConc," [nM]"," [molecules]"]},LabelStyle->Directive[FontSize->graphSizeCoeff*fontsize,FontFamily->fontFamily],TicksStyle->Directive[FontSize-> graphSizeCoeff*fontsize,FontFamily->fontFamily], FilterRules[{opts}, Options[ListPlot]]];

plotdetsim[species_,soldet_,sim_,t1_, iCell_,opts:OptionsPattern[]]:=
Module[{speciesplot,plotdet1,plotsim1,xmax,speciesname,legendtext},
speciesplot=species[t];
xmax=2Max[Evaluate[speciesplot/.soldet]/.t->t1];
plotsim1=plotsim[species,sim,True,iCell,1];
plotdet1=Plot[Evaluate[speciesplot/.soldet],{t,0,t1},PlotRange->All,PlotStyle->{Red}];
speciesname=ToString[speciesplot];
legendtext={speciesname<>" stoch.",speciesname<>" det."};
Row[{Show[plotsim1,plotdet1,opts,PlotRange->{{0,t1},All}],Evaluate[legendPlottext[legendtext,fontsize]]}]
];
Importing results from simulation
outputPath
inputPath=outputPath<>filenameSufix
SetDirectory[outputPath<>filenameSufix];
aTraj=1;
bTraj=1;
MemoryConstrained[(*simDataX=Table[Drop[Import["x_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
simDataXConc=Table[Drop[Import["xConc_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
simDataCellsTrajAvg=Drop[Import["cells_trajectories_avg.dat","CSV"],-1];
simDataXCellsAvg=Table[Drop[Import["cells_avg_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
(*simCellsVolume=Table[Drop[Import["volumes_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
(*simDataLineage=Table[Drop[Import["cell_lineage_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
(*simDataAngle=Table[Drop[Import["angle_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
simDataPosition=Table[Drop[Import["position_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
,6000*1024*1024]
simDataXConc1=simDataXConc[[All,;;;;5]];
Length[simDataXConc[[1]]]
Length[simDataXConc1[[1]]]
Plot individual cell trajectories
exportGraph=False;
graphSizeCoeff=If[exportGraph,3,2];
simplePlot=Module[{sim=simDataXConc,iCell=1,colors={Blue,Green},timePlotRange={0,1000}},

Show[{plotsim[U,sim,True,iCell,1,PlotStyle->Directive[{colors[[1]],Thickness[0.002]}]]
,plotsim[V,sim,True,iCell,1,PlotStyle->Directive[{colors[[2]],Thickness[0.002]}]]}
,ImageSize->graphSizeCoeff*imagesize,PlotRange->{timePlotRange,{0,10}},AxesOrigin->{timePlotRange[[1]],0},AxesLabel->{"t","u,v (nM)"}
]
];
If[!exportGraph,Print[simplePlot];];
If[exportGraph,
Module[{filename},
filename=outputPath<>"/simplePlot.png";
Print["Exporting "<>filename];
Export[filename,simplePlot];
];
];
Plot all individual cell trajectories in a grid
exportGraph=False;
graphSizeCoeff=If[exportGraph,4,1];
fontsize=16;
imagesize=500;
fontFamily="Arial";
simDataXConcPlot=simDataXConc[[{1},;;;;10]];
timePlotRange={0,simulationTime};
timePlotRange={0,simDataXConcPlot[[1,-1,3]]};

plotTimeCourse1=
Module[{colors={Blue,Red}},
Print["D = ",iFilenameSuffix];
Grid[
Partition[
Join[Table[
Show[{plotsim[U,simDataXConcPlot,True,iCell,1,PlotStyle->Directive[{colors[[1]],Thickness[0.002]}]]
,plotsim[V,simDataXConcPlot,True,iCell,1,PlotStyle->Directive[{colors[[2]],Thickness[0.002]}]]}
,ImageSize->graphSizeCoeff*300,PlotRange->{timePlotRange,All},AxesOrigin->{timePlotRange[[1]],0},AxesLabel->None,Epilog->Inset[Style[StringForm["Cell #``",iCell],FontSize->graphSizeCoeff*fontsize,FontFamily->fontFamily],Scaled[{0.05,0.95}],{Left,Top}]]
,{iCell,1,nCells//.par,Ceiling[(nCells//.par)/10]}]
,
{Show[{plotsim[Ue,simDataXConcPlot,True,1,1,PlotStyle->Directive[{colors[[1]],Thickness[0.002]}]]
,plotsim[Ve,simDataXConcPlot,True,1,1,PlotStyle->Directive[{colors[[2]],Thickness[0.002]}]]}
,ImageSize->graphSizeCoeff*300,PlotRange->{timePlotRange,All},AxesOrigin->{timePlotRange[[1]],0},AxesLabel->None,Epilog->Inset[Style["Ext",FontSize->graphSizeCoeff*fontsize,FontFamily->fontFamily],Scaled[{0.05,0.95}],{Left,Top}]]}
,
{Show[{plotsim[U,{simDataCellsTrajAvg},True,1,1,PlotStyle->Directive[{colors[[1]],Thickness[0.002]}]]
,plotsim[V,{simDataCellsTrajAvg},True,1,1,PlotStyle->Directive[{colors[[2]],Thickness[0.002]}]]}
,ImageSize->graphSizeCoeff*300,PlotRange->{timePlotRange,All},AxesOrigin->{timePlotRange[[1]],0},AxesLabel->None,
Epilog->Inset[Style[Column[{"Cells avg",
ToString[StringForm["<u>=``",Mean[extractTimeXList[simDataCellsTrajAvg,{U},1][[1,All,2]]]]],
ToString[StringForm["<v>=``",Mean[extractTimeXList[simDataCellsTrajAvg,{V},1][[1,All,2]]]]]
}],
FontSize->graphSizeCoeff*fontsize,FontFamily->fontFamily],Scaled[{0.05,0.95}],{Left,Top}]]}
,
{Column[{Style["X axis: time.\nY axis: concentration nM.",FontSize->graphSizeCoeff*fontsize,FontFamily->fontFamily],legendPlottext[xCell,colors,graphSizeCoeff]}]}
]
,3,3,1,""]
]
];
If[!exportGraph,Print[plotTimeCourse1];];
If[exportGraph,
Module[{filename},
filename=outputPath<>"cell_trajectories.png";
Print["Exporting "<>filename];
Export[filename,plotTimeCourse1];
];
];
Growing and dividing colony
Importing results from simulation
outputPath
SetDirectory[outputPath];
aTraj=1;(*test modification*)
bTraj=1;
MemoryConstrained[(*simDataX=Table[Drop[Import["x_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
simDataXConc=Table[Drop[Import["xConc_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
simDataCellsTrajAvg=Drop[Import["cells_trajectories_avg.dat","CSV"],-1];
simDataXCellsAvg=Table[Drop[Import["cells_avg_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
simCellsVolume=Table[Drop[Import["volumes_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
simDataLineage=Table[Drop[Import["cell_lineage_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
simDataAngle=Table[Drop[Import["angle_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,,aTraj,bTraj}];
simDataPosition=Table[Drop[Import["position_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,aTraj,bTraj}];
,6000*1024*1024]
Compute all the individual cell trajectories
Compute all the individual cell trajectories. The simDataXConc table contains the concentrations data for all the cells at each time step. However, cells do not have any unique identifier, but rather are just numbered from 1 to N. When a new cell is created, the simulation code adds the cell at the end of the table at N+1. When a cell is deleted, the table shrinks. The simDataLineage basically contains a list {c1,...,cN} with N the number of cells at time step i, where cj = cell number of cell j in the table at time step i-1. When cell #56 divides, there will be two cells with entry cj=56 in the lineage table. When a cell is deleted, it can be easily detected because there will be a gap in the lineage table, e.g. ...,54,55,57,58,...
Check the details of the following algorithm.

GraphicsBox[
TagBox[RasterBox[CompressedData["
1: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
53adW9j9YdeoyZ+t2zRv2oz8dZ0xZ/7M+WuWrrl55frV8xc/+3747Psp8KN/
wIfPn9/7+fl++vj2g8f9x9cv/Xfv+r0nd59cOX/1hYf3h9cfP3h/9Hny9rWH
z38Xr108f+ns6XMXzl3csn7zxLH/TnVwmunsMvCf/r079WzSuKmdnV1TuyZk
dEMHDCGfyK6tO90PHdu3Z/+RI0cOHz5M/t65fvvciTPHj7kfOXT00ulLty7e
OHn4ZGpc6uVzV154eH188548/tjBo1cuXU1LE38uECdsTCxVSkRQz8K2bNV3
nm8unLwwf/a8li3+aNqocWHrgsULFu3Vtcf4kWOnTXWe5uhsP/JfxzH2u7bs
OHPq7JkzZ8jEXzxziaz8XLv034UzZ8/RC7nx6uX/7t28Tx5z/vz5Mxznz14g
r/f6xRuXTl8mY9mzfffpk0wIFy6cvnjxzOXzpy56PvHy8/X38Xrz4OaDl09f
vvV66/fx86dPn8jfd298H9979Pzh8wfX7l88dZE8kVxOu585svfIyb3u85xc
B/ccOGrwqD7/9O3RvXe3Lt0n/Ws/ber0yfaOzk7TJts7ODs7Ozk5TZ3iPPlf
R7v6TatXrlHIumCNKtXr1qhTwNqmaOESRQqWKF+qYqVSVcuXrEyuNKjdqFa1
2uXLVmpYvxH5a4QZ21aqXrxQCfK51KvXoECBgkWKFCtbtjx5rrV1gUKFilSp
VLVZk+YtWrRo0qRJvTr1y5QqW7pkmQrlKpIHN2nSjNzYqlWrNgL+/PPP1q3/
HD1y3Mghowf3G3pk33HyWSxZtMIYM4mJiv1J+R3IJWjoIE64Hz22dOlSlU3H
yQzfet6q1R+Iq4ySK298vDetX0XLB7p88dKhAwf5s7p1+vvhg3tDBg3Nn99m
uvMMMpf+1aFz9Nc4tRY9uTyDfOurValqQJp8mEF+83y2FStbmuZ789pHlE4C
8X0ghahXG6n5l1IXzJ7j9/4DL6/ylLQVbsvSk9LYujRBfwBOdOm4Ij2lcrlS
h/budN+/d9KIMb3+6pIRmzx1/KQNq9a89fb28X7Jx5Sens62nigVE0aNGjNs
GBusMBWCyvnrl29t8hdGIsuX6uHz2su7ZOHiBSysnR2cEFk3UChRWkqPvzte
v3KVEd+Ht+8mRMQE+vpVL1+lVePmRIaSTwPONreizh063bx+IyEufsPq9WaY
yauHXlH+EeTKAtf5GcnpspSMpNjEvTv2VK1QJTo8KpfrIAWB7t960P2v7kjo
LVRyXkeu8+Td6zffeL3eun7z2uWrycoAuagclUqEp7EDw5Oik0M/hr179v6d
p6+a4cMvxS2LMgrF2dQqnyfBdkDiHhxvB+GC9OAai+ZNJhD5BIXdmWZPd3Wb
tYhVRnoJ/hxUpVwlVcgE9btx2brubbuqwqQ3Lluw7Mq5S0KXbFJsipmhuXq8
9N60xHRlqlIVAk7gGcrUhLRXnj6pCemf3we8fvFmzfK161esX7ts7a7Nu5Yv
XbF8+fIVy1auXrlm3Upq+9HdR5Jjkvm4iloWuX/5DuVtUAiuV5tlp3G31T3J
CvE9pHeRySPlKTkuhX0EwiDFIRN85xeC30LvlOoOKvJ40zf5mccLQ8zkpder
b820wK/IyhXLSpUsumXzuuiIsAd3bnfv3MXj8VNuJ/7o4V33Y4cYAd29a9vC
BXOYIoPJZnv37ChgaV68WBELM/Mtm7YymfP2zTtO9lNJY5CQarGKjY1dMG9+
bHRManJKcnKyUq4Qi69KroSWqTafnsoCUnOz0PIn9h2JCw7SiFXKz588+cbL
K/pLBGMAKjNkQZ/95ayjlT1+y+aNVpYWJYsWyW9u3r9nT8TMni2ZEvqXrF2b
mZgzX7gQvaF0b0BqgAbiX2SckUjmT1ly6riBI4b3Ghj3JZKfSYa7fOZ/yvSe
6zqHrEJMGD1enipjbgyeIpvp4FyzbJWaZav169znzn93cr8xyEIgP9/PIwaP
ZO4/V9CJulBKLzg3QEHT+6dqJ6JteHE45oamoriQIDTmL+F2tZDFi+aMtcxT
jvsa26rpH0IJKFO0LCepBKOnFoYWKfHJqqgpycNLFSzGjAzlC/yoL9GmmClZ
w2GCUsrxpw+fB30Ka96kFRMjjpQSaSZE6ZFWK/UKpbSuFSlQTNUMKnpPNUSH
38I/INXx7KL+jGiSElJJeRI+MoKtB0u8v5qSJ/m8JG4IgT5/CjTETEk1RAAg
hrF0IiNCjxzeN3fWjKmTHZ4+epyUkKzaS8gnO/xbqlSJatWq3Ll9nazS8R/6
oVcUAf4fr1y+6PPqNVf7UhcmzfeFL+GlGtokujer6aMW2F4shHiLlqvmy1tc
mFq2RUZQJDJRf/b7ePq4+93r19WKArUA2SlJCfT+na/E1fHBIqT2sUV2L06E
vPvMf6FVZUuq1Q2ERTHT+UFJ17TliK230/ZF3vjWKm0jdOvSnb9EteZjTXTv
1XUkXfYWzl9IR86UrjJJHSzhqeAMkAO7D3Zq/zdvS44YOHLV4tVI8DCd7afN
mjpb9VQJ6ia0bNTs4O79zMTX/FNuYffHo7uPebmMi0n8s1l7lI4qlqvKnSql
xVm8UVohzecipQXfgucn+EOS1Sz+7ZN45emkSvYeJ3XQyMA4JYUdIMyET2i/
EMk7T/C9gDR28Yn76OtviJmHBIZnet3AbwZTMxa4KgQqwCAeo6oqk3np4JWL
z4fCDKzlZcyk51imhRLS8q6Jj2CSqDMuLXotEZdQejSq0vqhSon0wGVxLZp7
NMJkqu62KLW8Mmp2Ecnl4CgiJHLWtJmqp6DFWGGOFmQt7nitT011r3Du5inT
FaYGJkhQF8M16ht8puV/uWoYLsrtktAHbly1sV/PvsyzIG3DEgVLUvUTxjJV
Ih+vN7YVbJmMwIaMo8/efiUtS9BfZeIThyaO/XfogGFC8+r2tTvL5q8M8/9i
W6m65A2SrDtlE1qdi+QvxeugPm8i4vRO9HrqHD+VliIzNjSJiYmTDjmz/Mzr
pq4D6CO8XvgYYRZfQqJ1BQcAYjKplmuWV/qXwKw85WR6pGPJVAdZslZuZFdq
MtFBjQvUWeuQKH/ykgCyKNG5k2fPnzonGl/AF26ir37gzBwL9F6kfqv4G6Rh
BVOBIPpEHEWHRVsZWrItd+pPQcPuFlXkcNHjEGulIAwqlkVzFuzZvptpk6pW
vtrzh88RzqVZiRrXbOT11BsJp9GWo1pla/q//KzaiKO3Xm8rlqrIuggZOVAg
E8xEliQPD4yoXrG6QEm/Ca3WFp3+SmWkBVcH1N0Wv026dJBAsZFxRpix1lj0
yNaZ6iBz0MsXb4wN8kV+kRBcAMguOVDnzPQNIyTW6L/0q5rqDlnrm6eq/2dy
pB67pZP37Uoq3JIDHrCfBY7c5i26dOGyqlcMN2hFU2gkvQSZuiuZiURYKVGi
ijYVUApCuET4SOq54GLJ1dBH0XZGXCuULs8oe6RfzB9126geGoFeP37Tv8tA
0TOk7MdNO9ZtRwrVYeRSqnBpf98AVWoItGfrntFDRiP6OxFMgyOhZTo0Uejq
f+r9ztI6WKZYJaGpninZqKz6vwmwq9UEETmg6RoIrpdAnz8GmWDm/124mQfr
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
w6jYNbGXfPYeRQV77y3WWKNiwa4YazTYa0xsWBAUCyigscaKWBFRFImiIohg
wQYivZcru/Pt3fa9XbiDO7wj7/Nbz2NvdnZ2dvb9zzttSxQvY2ZWvJhZ2epV
6rax6PJd2SqEF1C8ZIkyZcqpvpiXLlKkmBlRpzcvQXyULVexfPmqRc3Klitd
idjKlPyudKnylSpUrVKpesXvqxAREt/r12m8wm7tvn2HO3XqN8VmgWXr7nVq
/di1U996tZtUrlC9b6+Bq+w2LFuyau9ux317Hc+dPH/5gte+fU6O+w6+Cv40
YdycypUazJ2zfOeOw2tXb1u98s8FC+ymTZvfvn3PsqWrVKtSt0b1upUr/VC1
cp3vy/9Qodz/qlWqV/H7H4KD3w0fZl2/fsuiRUpXrVJrqvW8Lh36t7XqYWPz
68nTV39bvunXhavXr9v561y76pUbNWrQafSYebVrtapUufH339Vr1bLnuLGz
OrTv37XLoEEDx86euWT37oMOTq4BT0NkSo4Bw1FqWvatG36uLmePul28eOXe
jVv+vr6Po2NT1FqpMdzCxOA9Uz169Hj00J8qtLQOXr585uYNz6VLlwqO9PHx
OXrUjahFrN+whR+h4rdFCxvUqZsUm6iOKjfroc5oSgeZuiKO9jvs3bV9h5fn
jZ+HjeFK1+BBP5F/JsYn2C3/nfgSHZXco3t/OnqVAPXs2u3GVS/+jcnJeqib
XPCT7qdW/75GQwepClyA/6MqFSouXbjohJv71IlTipmZ285ZyEZJlJOElCNO
R8gqnzxD5uLsOmLQiCW2S7NTZGQcKxYt/a5Yyf32Duo/ORVkJZaRlkmZCEAE
iTZA8R26QJZPjt3VLmoJTzNfSTEcEj4dB16vNP9Ysm7JNoRw+w25TpmUrpFD
T2kHg4hMmYXdveF768qdsx4Xjzl5OG13HvnTmL7dBw7uO6Rdy3Yd23To0bl7
g9oNWzSy6Nyq2+gh463HTh02eOT40RMGDxq2cd2WbX/aHzl01Hn/YaI+fMzV
7YTHqSvnPW/f9Hka8OzJg8DnAUFhoW8i3nwKe/E2MuLr29fvkxPTCB8wNTlD
NcGZf4FKOWeoNi5++3DNX3CUkSorblbu1bO35AyOL5ExEW8/vnvz4U14RGhI
OLE9exp8/oJnMPHl+cvnz16+Cn0b9PRl4OPn4SFhRFX5WeCLi/94EpewZcOf
+/cecN53kLiQY8fc99jvP+zsce7M1b/+2rthw/YH958GPgnxf/jkeVBoyMvX
6WmyD+8iw169DX35mnBslTKUkYL27DxMKKMwiWR1AhN+4dQ01J90SMKGZ8vw
oKDwBw8fh4dFfPoYHR7+8fotv6vX7u+wP7h63V99+w6x3+Vw5PCxA/td/z5+
yfOKr+/9Z0FB70LDInv1+7l02eoyuQl3CKpRW2Q1GRkZE8dPYOpjtJ3GliyZ
h2PZdnbsNEAygK+vL6GDUybPSEuXcZ1Bwl2vVul7j6PH1JmsWZ/U0CMMz87M
4vqDZHNoUlxsKfPi5ctUTEvOYrsPEJo00ZqtNKofxuR4uaVFF07zAk5I1Z+b
NiPekytSs+WfEZ0+eWbNqrUatRpVM0TE23ddO3Zi60YYIgpwvdqNOOZQ1Viw
9y+HzNjMiaMntmjS3H7rzqB/gw7vPdS8YYvwENV8q3Mepzq0tGS1noxcHVvL
Ji0Jbf2P6KDucsHXwfzGxj9YFx2kdxSQDuangs1rwxfdqHAaiqbUkDaM88lN
EY7iY+MIG/38aVCA37++t++dO3nW7cixAw7Oe3bsXTB3Yc8uvQb0HNi9fa+R
P43rYNmFcJqKmJlbWbQd/7P17Cnz1v2++fjBk+c9Lvlcuxcc+CozKYsaiYrR
uimnNVRUajWvEeM05xH185WbeemnJADnpp+99dR+yh4KgjAB6R5/VO272u9e
RrIJ42cX1ZjJHqUhQ4iuJGCcc3LDIFrC2BvKXDV7sefP3KhcqUZOZUBsp6Dv
ifyL242DqROpmjnNeQkIzkk/s0V8TDYz++7Tp3ikcSoTcQ+FeuR5+UpCXDyp
itxgFi2byeXZy5cv5xyoukbvW3eaNWkRG5PI3h31fllGessfm9GFIKeaPBNh
SHCQu7s7+Z0eOak6sEb1qo4OBwRHNWvyI/sUqI3YKfeLc2yohb5VcwYxXJkt
69Gla87Xy0uVejvhcXzNmjXC39UFumH9BkkJiZSEqQOHv3r9fflKSjkVhwo5
sl+3z6pu+zue3uxzgaGk2OQli5aR5XbOtFm8yyEX2MhG5YuVq12tNnUU/+wm
Upy0QrPdTHPNPV41gd4v0nfM1nB0yx+hLRcMfMolNrYUSYueZhiMMx6YbBAX
f6cJkwM8qyt4jrSEq2hKdo0KZqIf5SYoEZ6JsmIVmTHyjLhMohYn+6pIikiJ
Co8OffLy5pWb2zZtXzJv2ZRxM2zGzmrTtGONSrVqVK1VttT3xYuVKl/++yqV
qjZq0PjPjX8Rwrftj+37HQ8ccHI+eujY5X+uyNKzNcWrbu0GHyI+i+symSol
xv2TkxcSV8kd+MINrERlzCvwhE/6huWWj/TdZLv+UZvmnS+fu8mVUdGCk0tx
wphxdLmEFBT19+8/kn2g585cK1G8jMQxvAQIx11wEyB1UvJWSJQ7smwSQlnU
vLKj47E85a0xILy/a1euSE1J0lzCpWnTxtHR0cHBwZwDVZnsYL+3Tcu2bPWG
jqdcmbLjx/3CHM7OfZAqhziWkZLsfsyNDsLWtFfYLf8Q8VFQixs35hfqkVF3
CH768Llz2542E2cz9520Hn1795O6Xv7ZeTq4evVq0TDTpk6nHlJEmbGI129K
FSsty1Ii5rIU6Iey9TxP3KRXf6Ks3dm/zyTGp5CP9ojBw7mXo57Lj8KfvZo8
0rpHu26FXgeRxhPNmnr+I6lRZcVxsaHyWkohV0nJcQFMxuaig1xDjcQKsKY9
V4GxP2Fs3Yk1TaJCgPNLKM7xg0jZVHLetoCJKYUgKiV68Tj42sXrm1ZtWb9s
k938ld3b9qhSrnqZkt+VKF62dKnyhJaVKFKqUpmqI/uNnTB08owJMzcs2zSq
51iX7cfuXPSJCHmXlZwtS5VnJyvkqQhPU21YFlJkqwZpyGU48+IJVra4ydZc
hQlHba06PHr4WMIO6Fyx4YTEmPo5Ig14NjIvUo6uQnDSKTwwV3gxM1H16DTg
kKO77hGyVgiTHLqaC9ymMIc9h4uYFZcIJ/hfIkzOQq2xFIngaEIHK1RsuGPr
QU3bZSIIdWHOjOmZGWmaOjh06FArK6uMjAymlBLqc8j54Bq71f17DWAeXrKi
26VLJ+JTNV6URswNp20g/d9i21//OXteM4n29vbJyezyaKQBGTpwCGMBrl7x
bN7sR4UMl2fz62w4ql+viVY5wJQEDPdwc1+3RtAuShm0Lp268qyNEm1fv7nm
d9UU6Qr68lWmyXrcZKREnD34aY+Tg/oMYKyTw559ly5c5jw+qq7ojKS0Embm
3dp3Y8cbMEalsOgg3fjCM9043crEs+pK2jXAcYSJSAbObRUXGE9yj5JjmTmO
OS8lbM+X2DBxjL8p+bFREUkHY86oXhaMO0qQbJ4PfRYaEfL26lnP00dPnXI9
efPijb+Pnjzi5LJ/74GDBw457z/scvjYjCkzrSzadGjdsV3L9q1btmnVrM2I
3uO7tx7QtH6LH5s2r1ezfpNajbt36P7rbNtFtouJetrsaXN+GTV+yi9TN/y+
ccfG7a6OLi77Xby9vO/e8g189PSx35PwF68/vv0U+SkqMvLLly9fo6O+KpiR
EJz2vb6dBvzrE8jLNyml5t1g/ndRA4uhbp173fDy5uUhzvmZVBzNw4Rnzdk7
xlR3WI6KmpVDuE6SpzU46tNt0O5t6gWQ9R+7JmLXq74XJ09cNi9WWjS8dqZD
93YG8uTMwGHCx6/XzuvKw0Kjg/FxMe3btUlPS6HUgRopiywsWt2+fQchah46
8eXw4cOqASoY8nB197xwhcyR2Nivffr0Cgl5QQQcP34804CMkGQ1j9HBXt26
v3oZKvxVqEeUJPXs3PX3xUv/2LBxQL/+o0eOkmfLNFwMVbA6tRtKRMWPk2NL
XzwPGth/AP9uUift3K7TujUbycAp8cn9u/U8eeTYp1fv7TfvYAoAEcn4cRO4
9f/hQ4fNn23LlEpiT1hoeMVyFQS25b63r7lZUZuJU14+C2Zii4yMVCppQ10o
IHOgY/tOfXv0W7ls1drV69avXbdu5Voii6wsLAf3/6lHl66WFi2HDxq6bNFv
RC2LCLDSbtWmDZs3rtmwfav9tcvXnfY5X7545d7d+3fv3vX1uXv3ju/2LdtW
rVi9euWa1StXrfjdbuni32znzl+yaOmObTt9fe49uP/w3t0HzwJfJCemCTVR
Q155iqaa05oVcN//3q17Xhe8vK/f8bl5584N7zs3fHb+Za8+3RrbuQt6dund
u1vf/j0GlCpSuleHnv2697MeN2nB3F8XLVi48NdF82fNmzt51qwJM4YNGDZ+
9IRpk6YPHThs7ux5xPUus126fP5vuzbtJETwwonzTjscjx108/a6Q2iW9y3V
Z4Dfv/HRCURKslNkGclZhHrK0rDJw+Z+Dk6gKktKjb4zQROoUkOXBeWIUxvh
Nh7Osplz8+rt3GwaWcoRXbnBcrWo5FPZs1vfS+ev8mpBfB0U08+86KBShsqX
qWoIy0wme/SIyRvX7hBVewMgqYM3rz8oVrQkkrKWeYuZOYOUG0hXOVVlDUMV
K1uc8FAtw87vzTQtq8Xz+mO+fmnUsL7NVGt3V5cnj/wf3rvfyqK1Zet2s+eo
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
tlnnT13+ecgoTlbpqIM5VH8xNHzQmPmzluRWt2AqgrltdAWJ+MzOUioVSJaJ
ZWXIM9JlmZnZ6emZaWkZxPf0tOyU1PTUtIzUlMwvUbGfP3399DGmuFn5UUMn
JiZkvA6PiI6Mu+Hls3rF5kXzV/62aK3DHpcF81c47Dl84bzX4kV2tnOXN2/W
YfiQST27Dxn583hiz8TxMwb0GznVet6Iob/MnbVwyKDRw34a//NQ60b1Wk2Z
NG+b/cGZc5eNHDmZ2H4aNK5J47aWlt2KFi1HbEXMSpmZlS5iVqFI8TrFStUJ
Dn1fCIbyFQ54jxWG2rVuW8g1xpjhWVHKOMZ8ji5lZv7Qy5canUIOU8mmR60w
m0Jj5D/GsSfcADL1xh39wmzZ9Can/8ziDIOR0V8U9EQDOT8GOW9LjUz5FPTx
y8so1U8p6OvLuLjXCeSLgTISiJoxeuYfMrjnMCp8Nn06GSfabM7gHHF5ZVVM
rGFctd7CS//QJTOWche1FvTsax6uUxs7BYbq1KzHvYMYRo6H5tdHpOtyOCNJ
3MBqHbRo2uoWOX9QQ/rFx+1I5ElO++n/CB3xvHxNWBTFqp6cSKj3o1FjizDm
YvgTXTE03Xq+7YzfpOozOMeNivoUR3zGRWdeu+LnuMdt49pd+3YfW75kw+JF
60cMnzLJen7PHkOrVP5f+XIVy5WtULpU+SJmJUqXqlCmVNWSxSuZFy1fr27T
+vWa1axRr1GDlp069P59+drRo8bPm7t46pTZY8dMsp2ztKhZmRpV6/1zztNx
r/OeHQ5vQt5GvY95/Cgo6lMMIZSxMUkB/z57/iwkLi4hLjY5OSkjIT6V+IyN
SYyJiYuLTYqPS0lMSCO+xHxN+BodHx4WkZKcmZKUnpyU/jUmMTYuOTEpLepL
bFx8cmJCKhGG2J+UmJaclJWSoHxw72WNmi1LlK4RGh6hZLMKzK5RQDbCtLJo
bYg6J6AVms3R6oekq2Wns66nbMbYTBgxcczg0cP7DLcePNHxj71zJs4c1mcw
8Xl0n4ub09Etqzf7XL3j7uy2cumqjWs2Xzhz6eLZy2dPnz/lcdptv6vLnoNj
fho5edTEP5ZtXDB5bu9O3Yf0/2n62KkzRtuM7j9m3xbHDy8+n3O9sG/j3pVz
V0wbbWO/fmfg7aenDpw5vf/MA8+Hnn9fjXj+7vTBv6+d9Lz2j1dYUPitS7e9
zlx32+d+fP+JG2dvE26X9yXvQN/H/rf8P4R8eHL3yYNrfq8Dwp96B4Y/fu1z
6d6Dy4+8z/l4HDwe4PfY6/ytCyc9DzkeMzcr7X3Jx2Xv0UM7XLet2r1zrcOl
415O2w8tm2fn5+W/dOZy6+FTrX+2IdzGi6euhAe9vXv9vuf5608fvbhyzjM5
Jpk3NliitSoq5Eujyo150wYlWrREPFylRr0CE3OQMXpFMu5AaE2/RtSVzuFX
jHLJWzez9Ll+l2pn0/SVMNYtYsoM8yvOXVCI3CNYMAHT+EkzSdzLz9FHw7Lx
rNRsn5t3L13wPH/uwuWLV90OuR8/cvK3BStXLNvUskmHYmZl69ZsaNmynVWr
9lUq1mjU8Ediq1ChUqVKVcqUrVClSq1mTaxaWXTs1X2AZctOvbsPtZm04KDT
3457jh5xOnn+zI2rnn5+D18GPnn7MuTTq9AIwpv7+CEqLTVLlo2npynIdGIK
/iWI3VlC8ggtE5YcOqOYTirpigSV4Xw/AqfWzuJ42WzeqrsI5ZnIae8x+52H
Tp+7miFTcmfwAN8carI/hiaOt4a7YlwwdWxNg0+b5Ue+Ae9CIz69+Uw4UG9f
vvW/9+iet9/tq96P/Z7c8rrtf9f/md+T5KiEpKgE7rGYgj8XQ1RKmMZJbnup
plhoNn5KxSNq/wUbf39GclbEq/dvX777EPb59Yt3wYGv7t18cOHERTcnt93r
9j68+mjrWvtJI6ctsll+av+5y26efzud3L5y2ypbu8XTF/1z9LzdzBU/Vmu+
cPIihz+cCG19cO3Ro9v/BtwODHv49mPgl7gXSelvspVRCGVyvGmu3814xFwv
NZV2XWVs4PrVLdcs3sr6swqNjclJzZ8UnJNyfXz1lwlDxndu3YWn12p9jI2K
l6Vhn99FBz19Ffw8/NnTkBdB4VEfk6I/JD99FPLk4XNie/Es7EXQq0f+gQ/v
P3lwL/DaJe8TR/+59LfX4V1Hd23ee8jBZf9e55NuZz1cTrs4Hd+/6/AhR1e3
wyeOHHAlvKTdW/fYTl/Uu0O/Dcs2/bHyL/ste34eMmrKhKkdrDp1turWqqGV
VZOO7S26d7DsUbNa3RrV/lfrh7p1azewbGE1atjo0SPHEduEcZPtlqxebLvs
3OnLN6/dffEkNOrd1+wUWWxUnGpxRfWNTkxM5hV4zfoDR5Qxbo8eQgKZYt8W
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
+K8CC4oCAAAAAAAAAAAAOfB/s1YYCA==
"], {{0, 324}, {600, 0}}, {0, 255},
ColorFunction->RGBColor],
BoxForm`ImageTag["Byte", ColorSpace -> "RGB", ImageSize -> Automatic, Interleaving -> True],
Selectable->False],
BaseStyle->"ImageGraphics",
ImageSize->Automatic,
ImageSizeRaw->{600, 324},
PlotRange->{{0, 600}, {0, 324}}]

GraphicsBox[
TagBox[RasterBox[CompressedData["
1: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
wr0Dx/YcmhmcgORo1ewli6bOmTtxevXiFW+b3dSEm4gKjjLetV8rBREnzMjz
R09uWbnW+bF9r7/bm+4+MHHYmMqlym9cul4lVgjtS5xW7N62q56+srN8NnXg
hDE9Bi6bMZtfWAfx+qpVw+ZKcZ7miNGBkX5uPpxLW3JEhqPta1Yj8QOmhAoV
w0raP7XTOUMCNavX9MLx85ovIsgztHqp2vJ0nN7X2up+Zmoad2Ja5zQAAAAA
AL4L+MGynNSM+WMnXjI+bH3J/PbZa2tnLTm189CNE5ccrewc7tlfOnR+7bwV
Y/qPXD5jybmDZw9sNT5/9Mzz+0/odOPM1Zunrt09bb5q2pJNi1ZuW75m+exF
O1ZvOrL7wKWTF8yOXLh29nqR/INwFB0WJZRe3Jja6xfOsydPnzp20msHZ96Q
pUT3zG6N7zNo+5JVfdt02rZ8nSwjh1MgKqnCz9PH47V7bEikju1IrZF0As4T
JC5XvLJ3nj5x+oBu/Qb3GHD3mrkkU6zdEem4nxFyXDcWFnPOI/sMbVq7IVLg
2u3sgWhZSClJjVbs1Lzj8Z1HGNuaijn/Hat2HjE+Itylc7sup4+fEprv8sSy
muVriZKzhIJz6cw1R7afoI9rvHP3qgWLOQF56YRZSnSC+pwh+igAAAAA/N/h
TDGsCJHI7p29eHKXyYPLtxWJ2WSa9I2N4+XDF26cuPbM/Eno2wBOG/AiQRBo
FCkQE7pTIfhUpRuttCh9viG7FqWZ0iiMdsU6XEkT0myumkviUlgPc1JbglpK
FXRQ3TV9dPNrbEEGz4p9rbc2tCJbmpedy5+bJpva3YsieEtXgPv7zi06dWzR
0cLM4qzxuSa/NjU7ZSaUasGBIXTiFpHmtsly5LWr/B4XEo8ElWB25PLWZTvp
Wn1ocW/x9Hm5iRn9OvZu16R1418a3r52u0hTNQEAAAAA+GYINUb+8UFh0AaN
V5LBMUSDjljqI3xK51+wc5fOEfPv9clH+fy98qkybtDw9QuX7au3m+4/HRUQ
XdCBhFMszx46u2HBeq1YlVKNaza6evIKMz5460HrBi1/L1/zzmVzOoMiU7Fk
1vJTJufpjyjyk+oZAAAAAIBvA8kHUVfl4RlJaTpWGg0FaJLCRcdPhCakFSUI
Kaa2t/EfGagrkpNkd8xuL56+cM/6nYumzv+90i871m7ltJYoIbMCVnbnmq3c
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
Er7Fdb8j9S+kYPOd/q9IE3lV+GMoaIbNB62ClMG4NEKtSKBgr8Dr565GBIWx
JnHdEyNR67qtL+y/gAjtfgXzBe4IAAAEsG0TmWW8Z+0bhydIJSdxQqmkG3dS
oK9k3h6Or17ackOETq/sMjLSOH0VHPQqLNhdJkkjyTx1PAQ8Iz5s2bypd+/c
ovgGBH/3xm7EgK4RIV6KPLFUkkuXzzYOVL4zodtK0dYdS6OiQ3UGvgzHUiAK
11eIVIzs37d7+7Y52VIDmZgOUT+OQeFHNJRP+ATNxUbA1a22gnm8RLkqSdTs
yYMoWS7betEtHsFfu2GFKTw089XEhAc3/K0WIlQGmnG9S6Zw4/XrA5xeIZXK
/Nw5Kk9RiN/sj66vhBTQa+S3bAi3ay0wmvi4OkvD5Ld4KHPzZGIJ+6VRMrHU
67Xb9bNmjo+feDi6LJsxd8OiFeOHjBo5YOg/f7Tq9FeHMsVLVyxbrnq5itXK
VvizTsP2LVv/06Rl41/r1an6S9d/2jWv16hHm3Yt69Rv/ludBZOMls6aM7L/
gE6tWreo26RH667j+49pULn+7+Vqj+s7tl6V+nSqXbFeywatf6n4a70a9RtU
a9juz/Z1q9SuW+W31g2bNaz2W6s6TacMmzy059AebXp0aNa2frU6tSvWalrn
j8E9BnRo2a5l/eZ0avpbs7/q/123at1xg8asnr985sjJphtNjq7Ze27v8ed3
bOzu2VhfvX1lzzHTtXuu7jV1tnji9fS1/W2b57ce3j93c1CrbnTauXjDrhVb
9q/fSW+3OWexbc6aSb3Hn9xlevPMrVtnzQ9tPLRhxpq987YeWWl8eo+pxXnz
q8cvbF+2YfOitfvW7Nq+bNuBzSZbFm/ev2Hv5uWb5xnNXzV/1dJZS6ePmblq
/prpo2Z0+6trzTLVKmHl61X67c9fG5YtXrpCmbLlSpYthZUsVaJs2RLlGlSv
O77/qH4d+jaq1ahp3Wa9OveeMXH23GnzNq3aun7FhpkTZvw7c9HW1Zt3b9y1
bdnmPat3m+4+ZXXxvigy08/J98mtp3Tat3a/8UaT51bPY4NjVGKlKlfFG42L
YqkjBYJKqKILyl/o7acXzq6QuH+8llOXye1HaX/zjCY/sHm/NDmXK8PgYXUb
HNBXAPCl4IwkCre3DmaXTiLOiq1/B9JCJTfI+1VSdCAipa9ePXd3c1YoZKzD
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
hFf2zmwPqGLaUBw3O3bixoVLOvqKwNu1bHbn0iXT3QfnTpypM0LyI+qrO5fN
hUNmRUL7IyS19YZ4MfPMwgrJSZ1hHf2Uz2VaKHLYJwNZorj/X7104hLwOSll
bp40S5yXnUO/UGSLs5PTctNFOalsysjOSkpPj0uWiHKy07NysyS59OaYxMyY
1JyIFOfbj426Dol57ev90i0uMCI2KCwqMCQ6MDIhNDYmMDwuODIjNjUpIpFO
kmRxelRyhE9olG90YmiiKCFTnpUrz5QoxbmqHKk8J1cllZESBcrBX5g/inYO
WD91KX+q3DQ6KTq8cgfKVOmcP45ivGK02Ug+AoPdnaeRrmF884AjWbT04Vkr
Pi5BHrp74iaSGpqyl18W4rojaPkrVm9HFXp0/gHiYvIVYs0zlLS+avmT8Nel
RP5vAlRifmm/T7918t13lN5kalbLeTq8L13sNwz7Y1Dffao8pJSiW9dcaS20
a/tjzjVdJUOXLzliWNN6dQe5uogYuYWjXAmaP/dQMezvHdse0EKL3hIWqqhT
u0/lSh1DQ5i33KEotb6yfSzCsAFHjroVupQEAABfh/xqoVBZlb/TFgy04VoT
vX4mvsUkCJXOITQNIBLEXtBGJSVJEsdx1iWMynt018LxmSP98sKZWzOnL4qK
iOZcm+xtrScMG3rr0oUZk0ZNnzw2NCBk1PBxvj4B6lK4x1Fa28jGDRmk5Hxa
tIY10uahpemxw+rOV6g5mRmRSfFRx08c3rJ3V2h8QQHn6ZLlE8eMPHXstG6d
Mfrq0f0bm9dvUHcizNy3hIiwUlgpsUgqeJRXbVm16PULa87hislGkKYmB8cP
G6lr+qCv9NHsidO0fj50raqIetV/6dexR5dmbTOiU/gT+MGUFQfbK925aC5K
yNC3zwivt/DeVrgjM75Nvbz9AEmUfPh0lSCEkXApTr1Eb8+Q54TEK+PTpeEJ
AU+c/Kwd+jRoc2Kt8QXjk4e37jfevHfZ3CVDevYd1qfvmoVLJgwZscBoxtEd
e60uXre6cNXC9LLtVUv7e09cnzu7P3N+YfUk4n3Yyycv/d/6Bb0LCH8fHB8S
lRwc++6Zi8WJS97PXvu/9nSyeeHn6mF7x8ra/L6b/WtvF086uTx1uXPpzvMH
zwLf+ns6uD+7bWN394Wz9au3z13fO717duPetcOme1ZvnDFi3OrZ/14wPnFw
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
XzHAoCgdzjfdPHLoLBxTbQ8y4vyqWZMXQKXzBKXmASWZ/LiBs+fPWs5QLzo7
7ZgMPb2OCUypWrr+hTN3cXbDk8NF0zdWAE1unXmckySRCTA6R0EOPtfsP0OD
agf2nbJ68Kp5k67ljGq+eOagTQfP8au/DJpatbbNjxT7iBOSA/fvXvLR2Xqf
5d4la1ajZENCMJhj8+Tq6ZN7sjOjnj25lZISRcmIlIlj9+/dbNOifrtW9Zo2
qli3hl7dSqBeZVC5jO7GtatCgnw9vdzvPbh749ZNf98AbftSdZXBUPnLp4+t
7t5KT05RXEVOHT/ctkWTKRMnTJ86beKEcVMmjzcxGdG1a2ujMgaTTSZdvXzF
7uWrjx/e2z5/evXKpeSkBHU2+RjrS5ZGBvlX0i+bFplcSFEpm7Q3z+7169g6
1M17UIc+gpTsvN0OBw7/ApQjIDXHkqaLrp++Su97gknh5SM3pakow6MQZj8U
Mkjg9w9BCd7xjDpGLQoeqkvM7KD40FgENRd+UIKHlUx1KcdlcUE5JkOWfHoT
pNybRiZBt6/fc3zXWWkk2qtB3z0rdpPvRQxtLjkun7YB55HMR54J+3cYf+no
fS0cnRUo80Sh+9uwBpW6hvmzulmKYiECOKSXyfL5axVL2FkkHCPbTO/OI6ZN
nK0heY1PmCZXceHp/TuO6NthiDATI9IU8WQyIUJ05PwM8bBeJrWNm9eu0KBR
reZN6rRu16LLhnWbiSJJJfDUics9uvevVrXu5ImzQoKitKh4Cb0p7fBr8ipq
Luz4v8FnWgLQUAtGX5YbTWNViWjCr55v9u5dKhRG3Lh34cjpIyjZLhEEzzxz
du+zZ3ez0uPeOdjKJdk4jrL5CY6IM1KiwwLdE2L9MWkCFEY8u3PSbOpEqrHT
XSqW63cU00JBqD4CBnGEDLSaj+6vcRkVUOYM6VxCEODjqgdAZEgES2nIGIPl
2jqqPCIlv5Knx8dW1CuH5SAF8itqBogJ+3Zu9db6od879xmjpuRdtvwXNCkO
HLQHrfcRwAu7zrWq2gwKyF5HkCzqUKc7kkxeSo5JmTdlAeSTx+mxGV9ffw39
GLpi3EqPlx4cv9ICJTFq4yRXyY5DJw9dvMf8DMNscYUkh1ZB8ODITmM2LNxI
kJlET8GE7mYJfpmkIEsKnW2/Na/VLSGMr8U0uSB+JcyE6xYeWL/4ECZmyTap
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
z8snT6pVqNC6adNTRw+fPmHZtEn9Q/v2EpMTXCYwX7HICIAhXXsoxFqKbHAU
FYudXr6ytXqcEBVH9hccxfpX8e/wKyQT93L2ZaxZxPDgmkMk15JDxtSKCjHe
UVV1K2fGZjIiCAQ6PHRcMHY+rTrMtbL+QYJSxOIX8+b8rCN/impjKiVIbKkR
lstDcq2PMHW35IlQaMifJjtltScLCAXHZ19CYHxM+gcnj1e2n65dfPzOwSsu
SuTsFHzh3FvLwy8eWwVt22I9duzh5Sse/7fcZvGC+4P77alQdrihQQdKcNSS
kh3RoRUlU2oIQBMAuujq9aG0cuRJA702ujpt9HTbGpXpYlS2T4VK48uUMzEw
GAd0Jlaqtqla7V2lyi5av/nD4ZNuz16FCaWUpAAlRhro5Q+TM6EEIdkR8a8E
hXw5nDjDChjNtXtHnpRTYgXivF8YrFR3CwBTb95J5uWQfTkxVvEEsFd/4mT/
YSN3xydSCkcUiuXQzlHSrtsGAAYA0Ltlq+l4CXGKX8CvSCKMYyhdYu34lWqe
/w6/UoKYCaS6OFmvmjcTSiRkw8qtI2WXhec8eHDF18Od9bBIfpXJC169dubk
KeM/f/mqOEnyq5xs/1atjSZPG5TBTyAaJkp5R8dZ8h8VkARJaPfikbW1FZtf
xUWHtW/RYeo4U6lYoioEQ3CZaMaUiSThoTR0EBcdPrC9YtlSEcGksxFElrZ/
39rdW7fm637zvTvyKsmv5OL0RnXqOb15x4qPkVNrXLpwhmmlUoYWO3f07txx
qdl8m7tWwjS+wq6AIEMyqTR73izT7u3aVypb3vbJU0qnTtAkebifT23jypL0
zOzU+AXTTWaNHHp+7x6KQbFLgNy/c7UUAId37Oraqt3hfYfyt39OUfg3QcPb
LHKvkm8HDa11WMXbeqN4PbPau9hjq5z8yOaPmuv09B0zOVO4vRLEZ5cHRilR
yTS54ifkVNOt9vzqU3KmJaaCVGHFQGbxU/rkYm4Jl59F5GEsuKqXgzxkQ8En
oTyXbTIaNzkrSBXPQaLgpew4MsgQUXaQsIJUhc0ytygTzBOBNnoVkAsQyAiI
4pdaXYjxIbO0UKJwVpAhp1PA+dQtdGoiyEsQCVJkiABiIjIOkaAoRZYakTV7
4qK6VZrqgDKADMYAVNEB9QBorAtaGOh31AWdAOgLwHQA5gGwAIDJAAysXm38
/AWnFi29MmHajSGjbpctv0Fff5lR6Vlz5lw9c+6d84eMiGh4847AsPRUoDNo
05bbAYF8X98M/4CcqFiYmAq/eMJmLTcalp5scSTYMwCu3+ZOpLl739tsEeWO
HWdM1gniNG/+bb1SE7/4QhFGGsSQtusY/OQuNSg/rZTx7Hef5FKKXxGBOB8Y
Brt03wnA8CZNF7l7SGnqFZcMx4zfD0CPcuWHLVt2RSIiWZYQgWduRwCDkc1a
/5eSAhX79pb8vKl4wweGqdc6FbWAGMvHkkbkS1RjLn/WvDIXJMcQ5sTtMF/5
5M4NXJJDfU7kBWqRhFQsyzp/8djTR3dJKS2u1LKLRNlhtWvqrVixAkHoyORn
j2KZ9+4d27JtQftuTVp0aLxs7eJ7j+6kpidp6gPpu0xNJ1paWkD6EZL+QGRC
Aa9vt34LZi7Ox8swTCocP3zIyaOHxYIsqSjL9ulDgm7t27XT/bMHxeIyPru/
3LRuTT79oCZ+JYSooEu7Ts8fPVflV2Jb61vldEFOchJEEWFaak3j8mWAbg2j
KihfrujVEblMOHfGDEMAvN2/KfpVcuupxNDwJlXrIBk55DZUmDgrPHDplPFQ
LKLjKG3PdmxbPWnMIIggUQHBndp0+DPbD4eiIV/fVTR+pZmkaYzzoyy9KD2b
yiJBDXcxcTBy2G1bu7W/e4Ciw6FAKdXTolIYsx8Ebl25pTKo2LVBxyFtB26a
a75r8ZaRXQbHBEUWwq8KlbFoKXvRxH/kCpohZ/0rhfJsGSZAcQku5kmEmaLs
hKycRB4/JVuSKRKmCfhposTIlJSY9ISI5Mz4LH6yiJfAT41OSwxPivkeG+oT
FuYdFvg5wP+Tj+tLFx8nn29vPcI8YgLdQtwdPL44fnV+6Wxz7dHNw9esT9yz
PW/z4vKz07vOHNxkee+ild2jN0Rwtv1gd8fu/SOnN7dePb305ML+i1csr1lf
enp086lVMzasn7t93dydy2dsOrjx1JUj907svvCf2cb5U1dtXWGxbtqufQuO
Lh69cvmk1bPGLJk6Yv6ssQunjJg1dfSsVYs29us8uEfb3vUq1Wlao2HTmo2b
124+rM/wTs27Nq/TqmW9NjXL16lbqUHdqo2qlqtVu0K9GuVqN6vVon7lhi1q
tunarGebBu2a1WxlBCob61avVq5eZaNa5XUrGutVql+pSb2Kjft1HrJ07mof
zwCaee7aegqAOgvM9hL9blIi9PCEDm/hhQti44obKxj/17/f0bt3wiVSKJVD
kQyGxcJu/e4AsLRBg71WD0VSKZTJYEYm3HvAz7D0rFp1F7q6YQhKSZlQktik
Z8EDFu+B/tAyxpNevZELpTBdAE9cSAZgcPdeq6U4DI3mJSRR82CM/HX/CitU
NQVGI5/YJ8kokRT5hnFoedID6I6uUnNmdBzFryhreeJXJocTJpwkUjMsPeTF
q3AZSsoXpAi8cdOrbt3xAHTR0+tWs2bfpHQ4bMplAMZs2uEglf9EfpX3i9M6
ciH8SrvElOQKQVVu0FQYdd4m1WT/+8oc1Bed5kvSiO/f9m9dNXZg15XzTa9f
vOjl5WX7+kVEfDgGRcnJ4bs3r7h35ZQkI40kDJQ9vPcn6/aNjE8cVvpVIJpS
2tWbhwODP8uQ7LTMpODQQP8A79S0RAwrwGaCnMc6f3AICg7EVcoj32S++tSx
o/m4L+kU1NnhVZ0axpXK69eoXunEcUsivkwqjI+LwqEEh7wMXtTqFctz+RWr
1uwHwFiYk+I7Wd9OvS4cO88qIyIXpDapXWnP9i1UE0EJLpSTEuv61q4s0Lly
8iJLRYitWb68f8/euBzJ5esoNF+y+pzFaWZdIUbM5QRHd218cOk8aTeAKbyb
QuTKxRPNG9eSi/gDevU6c+Ike5T5fVsRhxLCbzIhY7e0glqddsUttN2qEDA5
jAuJQSWqCwJxhcyHBgZlPEmYZ6jby49uL12sLtx7/eBlTGCUGv0gWyiEq5Ki
AsiSnGW/jahKgdgSHhGEWTiSQgzSECbBiDchXlZfHx29b7Fy36k1RyyXHFg5
evmc/nN6N+zVqU7Hni16jRswvmXd1nUr1u/cqEvrGq1b1mjRuGqTbk27j+tv
Mqr/hAlDp+5eu3+/ucX+NUcOmh8/sun0sW1nnJ+7vbj/xu7ha3eHLx9t39ve
Iv5383MOunXqydEdlx9de+5i/9n+6dt3tu8I6mVz0erFdRvf955eTp6e772+
vvvq+cEz2CM44EvAV3t3J2uHd48diUsBX4KCPcM8P/q5O3qGeESEekYGuEX4
fgr97ODt7RIYHZgQE5QYHZwU65fubxO+ftT2OxZWSYEZIV5R8eFpydEZqbEZ
SbEpORmCzBReZkqWmCfmpWZmJGZIsiWCDAEvLRuT4nIpxkvLISJkJGelJ2Vm
pfMlIjkiRgl6yU8XZCRmpsalpSakJ8WkZSYL+DwpL0OQEp9G3CLkieUilFye
ruyoERgRkFQa1Hxm/ZGgNwQ/ycyGc+a+LlVqronJVS8v0oAFp+yyREK4d7+v
QZlFhkbzH1mnEZxKRhllhQXDbl33ADB0ztwrsbG5TEkigS6usG3bDQAM7NBx
WeB3kguJxHD+km/AYB3QNRs+7myOFA4dZV65mulHF5I1yYmAwGe2sUaVpgMw
cuPOp1IqKYJHZUvhMnNrAEY0b7MqIoGUzyG0oS4Gs3PgmfPuwKAfAF37DzT/
4JJN8DoUhQkJ+P17ntt3Pjh93l6IQr1yS4HhPA8fMhfWwIf9WKeQO1P7lX2L
yqiqVmitrk+geVdBkq0/bgQs4KFTejqIZEb4f3Z4/vDy+XM+Pn4xibEo+f5l
pLSKF/vo5vmb505dO3f65LGDplNGblw21fbe2X3bN7q6fBQK+b5+X89d3BcW
6U7JUNX2aFQ++SbvGK1AJGgHruxmSe4hEfIwed7FQqSEiiyqlJ+VmJkWr3D2
jlKGXrSMW5CYHNGzS49C+RWdESVAw2KDo4l+nnWNIEsCU5NRzx5b59IwTJgd
H2kMdFbNX0x+BzRpxFFHO7uxQ4Yq/fYG+PgunrvQcp8l02kzUjIxRHK2rVn+
8NoVXmqqQgwo9/F00wOgjIGu5cED5BQLK5b6hsMfCG1ZzZ9QhoLvVS6NV3NN
uf26JsERwmidVDRcbI2Ycg8dhbtiUidFaQ8lmeLM2ExebHZaVFpMYEyId2hk
QER8cHyUf1SEd3iIZ0hsQIyXs+drK7u7F+9eP3vDcu+xG2dv37/88PLRS9dO
XD2688SW5Tv2rLeYMdZswqCJHRu269a0a4fa7Ua0HzKz77T1Y1aPaDB0y8xN
9y3vPD1u/e2hW6RTeNDroGSfZNLnvIAl1BJS/4rVqeQk6tR8ctUDKVw9Z+fh
rZdy1+Wh+aRn+Z+DVBGHTS/z7zqkvETET4a7p1pIozGKLrC0mWrle8pf5h2z
AvNmNcTPHyArEQRGBSSUATXfvvInusOYBDhpyk0DQ9Md298RdAinVxESDDcJ
nj7pq6c7vlkL83fOKIIwxvBfv4ibNF5mVNrk2HEXBMl1YyWVwuvX443KzipT
evzdO1GIjDSVT0yCq8xtAVhQocYBoLOocavNfBmpPRww8Ixxhfmun8W0jToR
XNxwgkcB0L3vEPOg7yLS4AqDydlwyX8ExRrYucfq76GMYQit8iFoYXAEHDNu
Z+Vqg4FuS2trV2a1I5WaGIUvHPlAb2nZiqtFMraapST5VR7fD8V32a2FRYHq
ay8kNltIhSg6ALURMGadqMZEfjsoJWz5rzC8hda1I8waN6q9UBWlzqOS7Myk
4EAvLy83Hi8ZItkQy3lj96BSJYPKVYxHjRmelBxNSZDk+ZLXhNyeNJ9GA1X4
cs/vRQVjPjNFc1JQIEYQlxQf1bBWo8zEbM0NFYO5+0fk7sXDKgNJfrIzUxbO
NTt54hhKTNJw8Z2rZ5vVrLx50ZLVZnMTw8OodcJkTESQXbOC0fhhAzf+t7Rh
zeoNatW6d+s2SfdwdmOnHqBcePn0ibJ6Oh1at5g1eWLNKhWaNqjTsU0LgmJ5
f/vKFIozcf/DUZRvX/seNa8OMQ9pKWqHkz9+fteOJT8BVj+5VQy+SragJCE0
/RAqKIqA9JFFBh6EaVASLkx0T3h18fX1fbfPbj9/cJXFkhFLhjYcOrrh+EF1
hzU2aty5QWeTXiarp6yZP2rhxrmbzM3WzR07d8eibXuW7do+f8fxjSfvHr/j
7egd6RMR6O7v98U/1C8iOigmJSo5KSKBl8LLSePzUrIzkrN4aTnZqdk5aTmI
ECENcWgilIx1qtXJ4fF7FbMoRJW04CwpGZvh5JGt5TFTz3OvBJoOn7dlyR4y
/fyiOUw1uzxX1fIZtYFcRA5PrD4vjJUwPSuTlLrtyXDWb8k2DxSmxQqrV+g0
fvROL1/Yd8AJQ/0Jjx/GyWW02QX5hBMj4IBuuwAY0KHDymw+5XUBgYgYnjru
X9rQxNh4rIennDhJ+z0g7kKl8O6tZD29GY2brgkKJGkYccbLE7ZtuwmAUdsP
ej1zgMBgcalyc6QUNXpthxjoTatde1FYBCP+Iib/WTnw9HlXHf1eAHQ9f/GL
jLJ4l8jgQ6sQXZ0h1atO9fGUMB4kaLdaOJTKYBYPJiWK+HxU+ZzJNY84vHwv
AgCz9h0skdwrvxYllGX+ZHDmGRQUE1fQMKYd0ZwEp12u0rZvpKURKS6RIzKs
8EWJvwvwPH+1vot5AsqJkxxnehOCTeUIxSkCIU/BVTTtDaYWWlqeaIyjMgFX
lFCck9WgRmNxFqINv9JozUJ5McVQ+fZtWwYN7jdkcL+1Kxd7u36ifal8dX7H
8Cuy/5FLc9Ivnzq6f9vGa2fPkcp++nzeEpJ27zR9dXnv+OT+HbcPTrQzF9sn
No3r15s8boKj3RuZQPR/+uQ4lBDyTMmLFDDVX7WDJpZvAM0/nhZ1eFVbEky1
VMoa5S9AnrtQ1i/COskOLBEKLoaZcfxIn6iAT/6uL10eXrB6ffe13R27a5bX
Dq+z2LFg99pp61dPW7t3+d5z2y4uHLVobJdRZsNm7l+6Z//ivSfMT1muPn7T
4vazi7bBb4NgDHy++7X3nSAskTGrJoOYZbMtyXdSziI5bC9PuOZnSNqfwsZV
m72yccztVDVR3MK+5YIM6nCSyy2bsmbfaguNXlVV0y/m1B6h+NX6c6IktkhF
bf+sTY9drMJQD1ySDds2HWOo06dGzRUVqyxydcFwOSPLIAqWHAt7tFunD0Yt
X3xLLGbEU2I+tNj7rLT++JbN1wR9p2RZKJOeVAovXQgqU3ra1Om3Y2LJ8wRJ
+/pZ1KjBPABGHjziycdgcBysUnsDABO8/XBSviSGy5Y+AmDsLLO7pPk6zjQK
GQYDg2H3HqsA6Dx16nYv7zRSVyiHNlbxxmXHA9Bt8aJjOXyFiy2KZaFK5/AK
vxY0v3rzQQbArM5dDirL+ZM6+zysBqdbd3HpcR5ZFnFMi5jU5qiMiTFuyXD2
10N+/fmWy7Mi4FIcV85XcqtQgCT8z4QGW1yl0AlV7AeNsSNr8wRK5CmpK540
LTmucb0mIp4MMq+G3UsUyOhUGjqbKyqqTG+fQFJsjNQPMi1J6flOIYvQKINS
+nlhBeoWqVji6vhhSM++RkC3b+cu548fzclMU9Dav6c5/eXIz0byq7ryEAxE
lY2whRIylkhEqfSR5rMLYot9lFnkEacUsE4fzRcwliUSWwOVx0KJnbuSSinl
TlKWzksGxYki0nIpgxzEM0J5VqefXNh5ddWUdeN7T2tVvfOEvrMt1p0+tPqw
3a2XqSEpaRHpSUGJWTE8YQpfkilG+ZiMJyd+MQEx+EHigCFFsnyPiFrRNq7l
FMdLn6iVYBqqhuZ7LPkZVMHASFusxpWaeLsEqHQneXjOjw+cFL+a1G/2zSOP
VNUCrH5Mcy6qAvkCeRECkXi41nSbMFmq0oBLGmp6M6WIjPp2pDmwW/uJALQx
LjfGw5MST6GMPQUqgkvnXiqlM+DTB75MxmxqQ9wV9j2zlF7z5Usv8HMYiROd
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
zCBOL2YlpktieXZaVoh/YKi3f0xgiJv9xztnrj+8eO+j7Xv/T57f3bxeXHtE
ciHPCCxFIojN5EWmy2PFUADRFGF2dKokMQfycJgFkQQpI2zJhB8fOVcA5URR
2blqO9q8hzbJFrFWjeW3gsbUMT32WjDqUkZ4enlgTKrG2EZBmKoYTQ5VqAtb
d8Z2NSBV9R5J/yuE1sceVAcVpbEiRu+W3848X6lUkspzNc9aNhnE0rCqoIrf
B1/4w5+kRi6kvIDADZPXPT/9XGs2gsFi8auUoBRjUD7SL1ITv2LKpd4RWVH4
lQz2bzpqxwKL/DUqSS9nKAx2Sx/fd4Gmd6SSeB4JcD5JFCaCIb7RH1+5Pzz7
dM/yg/PHLFhusnz7/F1rJ23YPGP3tT1WZzbfWjxh44rZm1bN37p2wfb1i7bv
N7c8ufP82f3Xbe9/vXPZf+Uiq9pVZhiAQQagOwDtAGitA1rq6DbSAQ11QGMd
0Jzy3N4GgC4UselCxWlChXYUyelKbfNHn2+rOEP/qzzTmQodqdCJOu7BbJFD
xNTrDXT7UrsKdqbIUnMqO5o1EaEDlRp5b4UqA3v1XTrb7MDho08d3kV5+eaE
hKO+ftmeHmkeHsnfviX4+KR6eicGh0uFUtIpBColg0xG+uNC2euZNPMrTet8
NXmpIj7KBAGcssjJoOxBoL/OJQDGyeDtj7Bcy7ug3C39cpYOLijtU6JQ4KSH
cUSVuqhpvQXoa5TytBwUPnaCFRtvGTDuQiKP1JPSdcchs/hfSaJoPoYzl0hD
HMWEjLHFkRNlQjA2p1LHA9mPsKj45/lVXiDU+iIehCnZWaErli4oSTLL4beE
4ttRfAsYORjtXLW5LChVVd94QIseswaaDG7bc+KAEYe37rp57tLlU2eDPH14
Salk15bf5Cn/SIGwzLPzm+7IYYxPdE29quSKNoQ14uQRzigtfDDWsVIgnmeo
yqMRI8bxsNQ65euSPSamWm12yH+jlhpPSoOZ5JdQAZTlE12eysIxdeva8rA7
tfZLmOqxHOJ8vDwo5/3BS02PlVf0oVWfVlCficA9i3ZaHbuvSYugcm+xuwiM
ePWxFUCFpLAkFQNcOlXteI6aWqitmAyunrRlg+kucgTSInoxgcJ3j/16NBtD
PzdNKTNGZZjCmkeimFDwYHJA1qXDd2aNW9KwcqtOTXoP6TnKzGTxnVPWEd/i
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
dJ/Wr0H/YU2GTus+fULHCd3/7la/YoN2f7cf02vCgnGLz+26unnBzt1rjrrf
eZ8Uooz6GOP/NODSnsserm9484FaKE1mHt30hf5Bi9ubrKQtvYEWLU7maZ4p
PaRXsJlGOq/GrMn/2j86th5KSJnSZXs3brnZMffskiXn8I4/lo9OHzP+PCd+
ylecIYapt2x3vMhP/378DLEU/LsxgTgMfPxMSlvvxGf5BEafj9ExMULYPMMb
jmr9vYPYj/X0h0Wrrmze+kCt5hMM17t84LTWgvkPFRq4fi+GkIYnzkSpKN6z
1qLDDkI6tOuyQaWtP2/4Nbf4bjApPSTa06LjoG79BYS0Gz3xTHC4tia8jIIN
O3wcC4/aeoBu0ekEIa2XrLsVp4FRM9+SHJOJ3bgjVyBMCQcvaUiOzoS0b9n5
6KdQsYS7yZuhjbBKoqHfRA+SawGxG9Nl2M3Nh+KITcu67TZ6BEP5v/dWqL0m
Ig4UFBy/piROfSYve373A/SaErJgC4ycFUAchxHSuWTFKQ8D4fYnaNbtALHt
ka/YoOd+4EnDxuuJNnmnEDKakK71W6z9o9ZSkqMb9/uctR8f+8GOc1Cywkkb
x71OeXfZ5VlD7Ccv36OetcqX5BtUotLi/RfA5XBA/wm7W/VYsnD91WfeiiRW
e7ugELyKKprRR7zzF06GFu7tgBNXUu5FMXwSYgqZKEgGQH31/4cgSK6dvuz1
5I3Wu28++5hPRozxPMiYrbE4VQnKQRaWUMymkPfjD1pPSkpqwXxaNHkolYx1
UWNQKcywjLEHx3BRGk+4YmcZ3krDQhK/sIn8HSCbCHvW781NnGKDoi1P9ya/
64Oi1WZywnwMgtlk7ZzVhW0LJYVKhBtOwa4i1UkmTnNx174kYCXAJHBDAk0s
5fvSL+BN4Ju7b6/vv/r6+uuXV95e2Xt918p9Z/Ze2L12/5IpS2eNmu08Zta8
yQuWzlg2ru/YdrXbNK3cuHHFRn+UqFKvYn1HUiAPKTpj2NyZA2etGr96/6L9
l3Zc5nZy+N+ztw899nrg6/XQx/uuj89dP7+7AT63/BPeSjV+LB3IQhjwSzBo
fRIq41phJnXMVAa1v5LVCGOueFMm9WvUf3oFS8mukkGrVPr1le6ewHBlWFDS
Jy91bDz4BUEOh/mVq7iIuYSXriTY5RrCTdx/VF8nqo4aNdbkKzDdNwycF98l
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
ALL0FQBAlr4CAEiaVP+BkQ==
"], {{0, 357}, {800, 0}}, {0, 255},
ColorFunction->RGBColor],
BoxForm`ImageTag["Byte", ColorSpace -> "RGB", ImageSize -> Automatic, Interleaving -> True],
Selectable->False],
BaseStyle->"ImageGraphics",
ImageSize->Automatic,
ImageSizeRaw->{800, 357},
PlotRange->{{0, 800}, {0, 357}}]
(*Compute all individual cell trajectories.*)
simDataAllCellTrajectories=Module[{cellIndicesTable,cellTrajTable={},simData=simDataXConc[[iTraj]],simLineage=simDataLineage[[iTraj]],end=False,iLineageEvent,nLineageEvent,it,jt,newCellIndexList,nDivision},
it=1;jt=1;
iLineageEvent=2;
nLineageEvent=Length[simLineage];
(*Cell trajectories table. Each individual cell has one entry in this table with its trajectory. Each time a cell is divided, a new entry is appended to the table.*)
cellTrajTable=Table[{iCell,0,{}},{iCell,extractNCells[simData,1]}];
(*List of the active cells indices in the cell trajectories table. Keeps track in which entries in the cellTrajTable (=which cells) we should write the trajectories.*)
(*WARNING: CELL INDEX IN SIMULATION STARTS AT 0, CELL INDEX IN THIS MODULE STARTS AT 1.*)
cellIndicesTable=simLineage[[1,4;;-1]]+1;

While[iLineageEvent<nLineageEvent(*+&&iLineageEvent<=6*),

(*If the time of the lineage event is the same as the previous event, do not write any value in the trajectories table.*)
If[simLineage[[iLineageEvent,1]]!=simLineage[[iLineageEvent-1,1]],
jt=it+-1+LengthWhile[simData[[it;;-1]],#[[3]]<simLineage[[iLineageEvent,1]]&];
(*Print["it = ",it," jt = ",jt, " next lineage event = ",simLineage[[iLineageEvent,1]]];*)
(*Append the new time step values to the corresponding cells in the cell trajectories table.*)
Do[
cellTrajTable[[cellIndicesTable[[iCell]],3]]=Join[cellTrajTable[[cellIndicesTable[[iCell]],3]],
extractTimeXAllSpecies[simData,it,jt,iCell]
],{iCell,Length[cellIndicesTable]}];
it=jt+1;
];

(*Update the cell indices.*)
(*Cell index start at 0 in the cellLineage file.*)
Which[

(*Cell division*)
simLineage[[iLineageEvent,3]]>0,
(*Print["cell division iCell = ",simLineage[[iLineageEvent,-1]]];*)
nDivision=simLineage[[iLineageEvent,3]];
(*We treat the mother and daughter cells as 2 new cells with the parent number of the mother cell.*)
Module[{iCellDivision,motherCellNumber,nCellTraj},
Do[
iCellDivision=simLineage[[iLineageEvent,-1-nDivision+iDivision]]+1;
motherCellNumber=cellIndicesTable[[iCellDivision]];
nCellTraj=Length[cellTrajTable];
cellIndicesTable[[iCellDivision]]=nCellTraj+1;
cellIndicesTable=Join[cellIndicesTable,{nCellTraj+2}];
cellTrajTable=Join[cellTrajTable,{{nCellTraj+1,motherCellNumber,{}},{nCellTraj+2,motherCellNumber,{}}}];
,{iDivision,nDivision}];
];
,

(*Cell deletion*)
simLineage[[iLineageEvent,3]]<0,
(*Print["cell deletion."];*)
Module[{iDeleted=0,indices=simLineage[[iLineageEvent,4;;-1]]+1,deletionTable,deletedCellsIndices,shift},
deletionTable=Join[{indices[[1]]-1},Table[indices[[j]]-indices[[j-1]]-1,{j,2,Length[indices]}]];
(*Print["deletion table = ",deletionTable," length = ",Length[deletionTable]];*)
shift=0;
deletedCellsIndices={};
Do[
If[deletionTable[[iDeleted]]>0,
deletedCellsIndices=Append[deletedCellsIndices,Table[iDeleted+j+shift,{j,0,deletionTable[[iDeleted]]-1}]];
shift=shift+deletionTable[[iDeleted]];
];
,{iDeleted,Length[deletionTable]}];
(*If there is one remaining cell deletion, it concerns the last cells.*)
If[shift<-simLineage[[iLineageEvent,3]],deletedCellsIndices=Append[deletedCellsIndices,Table[Length[deletionTable]+j,{j,-simLineage[[iLineageEvent,3]]-shift}]]];
(*Print["deletedCellsIndices = ",deletedCellsIndices];
Print["simLineage event: ",simLineage[[iLineageEvent]]];*)

cellIndicesTable=Delete[cellIndicesTable,deletedCellsIndices];
];
];
iLineageEvent++;
];
(*When a new cell from a division is deleted just after its creation, it results in an empty trajectory. We cannot delete these empty trajectories because the cell indices in the cellTrajTable would get corrupted!*)
cellTrajTable
];
Construct genealogical paths
Input one cell trajectory of the ones computed above, and this algorithm climbs back the genealogy path to construct a complete cell trajectory (finds recursively mother cells).
$RecursionLimit=1000;
inverseCellTrajTable={};
Module[{childCell,parentCell,simTraj=simDataAllCellTrajectories,iParentCell,parentCellTraj,computeInverseCellTraj},

parentCell[cellTraj_]:=If[cellTraj[[2]]>0,simTraj[[cellTraj[[2]]]],{}];
childCell[cellTraj_]:=Select[simTraj,#[[2]]==cellTraj[[1]]&,2];

computeInverseCellTraj[cellTraj2_]:=Module[{inverseCellTraj={}},
parentCellTraj[cellTraj_]:=Module[{parentCell1},
(*Print["cell ",cellTraj[[1]]];*)
inverseCellTraj=Join[cellTraj[[3]],inverseCellTraj];
parentCell1=parentCell[cellTraj];
If[Length[parentCell1]>0,
parentCellTraj[parentCell1];
];
];
parentCellTraj[cellTraj2];
inverseCellTraj
];

inverseCellTrajTable={};

Do[
inverseCellTrajTable=Append[inverseCellTrajTable,computeInverseCellTraj[iCellTraj1]];
(*Compute the trajectories of the last 10 cells.*)
,{iCellTraj1,Select[Reverse[simTraj],#[[3]]!={}&,10]}
(*Compute the trajectories some cells at random during the trajectory.*)
(*,{iCellTraj1,Select[simTraj,#[[3]]!={}&][[Table[Random[Integer,Length[Select[simTraj,#[[3]]!={}&]]/2],{20}]]]}*)
];
Print["inverseCellTrajTable: ",Dimensions[inverseCellTrajTable]];
];
inverseCellTrajTable[[1,1;;10]]
Tree plot of all the individual cell trajectories
Extract x positions from the tree plot graph and use them for the custom tree plot below.
treeplot1=TreePlot[Map[#[[2]]->#[[1]]&,simDataAllCellTrajectories],Top]
xcoordinates=ToExpression[
StringReplace[StringReplace[StringCases[ToString[InputForm[treeplot1]],"VertexCoordinateRules ->"~~__~~"}}",1][[1]],"VertexCoordinateRules ->"->""],{EndOfLine->""," "->""}]
][[2;;-1,1]];
Clear[treeplot1];
Draw a custom tree plot of all the individual cell trajectories, version 1 constant cell density
treePlotObjects={};
treePlotsimTotalTime=0;
Block[{$RecursionLimit=100,$IterationLimit=6000},
Module[{objects={},childCell,parentCell,drawCellTraj,x,dx,dx0Exp,dx0Lin,totalWidth,t,simTraj=simDataAllCellTrajectories,plotCellTraj,posCellTraj,simTotalTime,initialCellsTraj,speciesColor=GFP,colorGradient,xScaleFactor=100},

parentCell[cellTraj_]:=If[cellTraj[[2]]>0,simTraj[[cellTraj[[2]]]],{}];
childCell[cellTraj_]:=Select[simTraj,#[[2]]==cellTraj[[1]]&,2];

posCellTraj=Table[{},{i,Length[simTraj]}];
dx0Exp=100;
dx0Lin=10;
dx=10;
totalWidth=200;
simTotalTime=Max[Select[simTraj,Length[#[[3]]]>0&][[All,3,-1,1]]];
Print["simTotalTime = ",simTotalTime];
Print["nb of cell traj = ",Length[simTraj]];

colorGradient[xconc_]:=Module[{colorGradientBase,cmax,cmin},
colorGradientBase[x_]:=Blend[{GrayLevel[0.6],Green},x];
colorGradientBase[x_]:=Blend[{Black,Green,Orange},x];
colorGradientBase[x_]:=Blend[{Black,Green},x];
cmin=1GFPMin;
cmax=1.5GFPMax;
colorGradientBase[Min[Max[(xconc-cmin),0]/(cmax-cmin),1]]
];

plotCellTraj[cellTraj_,x1_,y1_]:=Module[{y2,nSegment=10,dtSegment,segmentList},
If[Length[cellTraj[[3]]]>1,
y2=-cellTraj[[3,-1,1]];
dtSegment=-(y2-y1)/nSegment;
segmentList=Table[
Select[cellTraj[[3]],#[[1]]>iSegment*dtSegment&,1][[1]]
,{iSegment,nSegment-3}];
segmentList=Union[segmentList,SameTest->(#1[[1]]==#2[[1]]&)];
Join[
{{Line[{{x1,y1},{x1,y2}}]}},
{{colorGradient[cellTraj[[3,1,1+nSMilieu+pos[speciesColor,speciesCell]]]],
CapForm["Butt"],Line[{{x1,y1},{x1,-segmentList[[1,1]]}}]
}},
Table[
{colorGradient[segmentList[[iSegment,1+nSMilieu+pos[speciesColor,speciesCell]]]],
CapForm["Butt"],Line[{{x1,-segmentList[[iSegment,1]]},{x1,-segmentList[[iSegment+1,1]]}}]
},{iSegment,Length[segmentList]-1}],
{{colorGradient[cellTraj[[3,-1,1+nSMilieu+pos[speciesColor,speciesCell]]]],
Line[{{x1,-segmentList[[-1,1]]},{x1,-cellTraj[[3,-1,1]]}}]}}
]
(*{Line[{{x1,y1},{x1,y2}}]}*)
,
{}]
];


drawCellTraj[cellTraj_,x1_,y1_]:=Module[{xChild1,xChild2,childCells},

(*objects=Join[objects,plotCellTraj[cellTraj,x1]];*)
objects=Join[objects,plotCellTraj[cellTraj,x1,y1]];
childCells=childCell[cellTraj];
If[Length[childCells]==2 ,
If[ childCells[[1,1]]<Infinity,
(*
xChild1=x1-dx0Exp N[Exp[-4cellTraj[[3,-1,1]]/simTotalTime]];
xChild2=x1+dx0Exp N[Exp[-4cellTraj[[3,-1,1]]/simTotalTime]];
*)
(*
xChild1=x1-dx0Lin(0.5+2*RandomReal[]);
xChild2=x1+dx0Lin(0.5+2*RandomReal[]) ;
*)
xChild1=xScaleFactor*xcoordinates[[childCells[[1,1]]]];
xChild2=xScaleFactor*xcoordinates[[childCells[[2,1]]]];

(*Draw division line*)objects=Join[objects,{CapForm["Square"],colorGradient[cellTraj[[3,-1,1+nSMilieu+pos[speciesColor,speciesCell]]]],Line[{{xChild1,-cellTraj[[3,-1,1]]},{xChild2,-cellTraj[[3,-1,1]]}}]}];
(*Print["xChild1 = ",xChild1," xChild2 = ",xChild2];*)
(*Draw child cells*)
drawCellTraj[childCells[[1]],xChild1,-cellTraj[[3,-1,1]]];
drawCellTraj[childCells[[2]],xChild2,-cellTraj[[3,-1,1]]];
];
];
];

initialCellsTraj=Select[simTraj,Length[parentCell[#]]==0&];

Do[
drawCellTraj[iCell,xScaleFactor*xcoordinates[[iCell[[1]]]],0];
,{iCell,initialCellsTraj}];

treePlotObjects=objects;
treePlotsimTotalTime=simTotalTime;
];
];
exportGraph=False;
graphSizeCoeff=If[exportGraph,4,0.8];
fontsize=graphSizeCoeff*18;
imagesize=graphSizeCoeff*800;

treePlot=Show[Graphics[
{Thickness[0.0008],
treePlotObjects,
Arrowheads[0.02],Arrow[{Scaled[{-0.015,0},{0,0}],Scaled[{-0.015,0},{0,-treePlotsimTotalTime}]}],
Inset[Style[Text["time (h)"],FontSize->fontsize,FontFamily->fontFamily],Scaled[{-0.02,0},{0,-treePlotsimTotalTime/2}],{Center,Bottom},Automatic,{0,1}],
Inset[Style[Text["0"],FontSize->fontsize,FontFamily->"Arial"],Scaled[{-0.03,0},{0,0}],{Right,Bottom},Automatic,{0,1}],
Inset[Style[ToString[StringForm["``",NumberForm[treePlotsimTotalTime/60,1]]],FontSize->fontsize,FontFamily->fontFamily],Scaled[{-0.03,0},{0,-treePlotsimTotalTime}],{Left,Bottom},Automatic,{0,1}]
}],PlotRangePadding->Scaled[0.01],ImageSize->imagesize,AspectRatio->1/1.5];
If[!exportGraph,Print[treePlot];];
If[exportGraph,
Export[outputPath<>"/lux02_bR20_bI20_plot_sim_induction_GFP_treePlot_"<>StringDrop[filenameSufix,1]<>".png",treePlot];
]

exportGraph=False;
graphSizeCoeff=If[exportGraph,4,0.8];
fontsize=graphSizeCoeff*18;
imagesize=graphSizeCoeff*800;

colorCodeTreePlot=DensityPlot[z,{x,0,10},{z,GFPMin/GFPMax,1.5},PlotRange->All,ColorFunction->(Blend[{Black,Green},#]&),PlotRangePadding->None,AspectRatio->15,ImageSize->{Automatic,graphSizeCoeff*450},FrameTicks->{{None,{{GFPMin/GFPMax,numberString[GFPMin/GFPMax,1,2]},1.5}},{None,None}},
FrameLabel->{{\(c\_\(\*ToString[GFP]\)/c\_\(\*ToString[GFP],max\)\)//DisplayForm,None},{None,None}},
LabelStyle->Directive[FontFamily->fontFamily,FontSize->fontsize]];
If[!exportGraph,Print[colorCodeTreePlot];];
If[exportGraph,
Export[outputPath<>"/colorCode_treePlot.png",colorCodeTreePlot];
]
Draw a custom tree plot of all the individual cell trajectories, version 2 exponential growth
Dimensions[simDataAllCellTrajectories]
nCellsFunctionData2=({#,Nearest[simDataXConc[[iTraj,All,3]]->simDataXConc[[iTraj,All,2]],#][[1]]}&/@(Max[Select[simDataAllCellTrajectories,Length[#[[3]]]>0&][[All,3,-1,1]]]*Range[0,1,0.005]));
nCellsFunction2=Interpolation[nCellsFunctionData2];
(*treePlotObjects={};
treePlotsimTotalTime=0;*)
Block[{$RecursionLimit=100,$IterationLimit=6000},
Module[{objects={},childCell,parentCell,drawCellTraj,x,dx,dx0Exp,dx0Lin,totalWidth,t,simTraj=simDataAllCellTrajectories,plotCellTraj,posCellTraj,simTotalTime,initialCellsTraj,speciesColor=U,colorGradient,xScaleFactor=100,colorGradientBase,cmax=10,cmin=0,nCellsMax,nCellsFunction,nCellsFunctionData,thicknessFunction},

(*X and Y coordinates are inversed!!!*)

parentCell[cellTraj_]:=If[cellTraj[[2]]>0,simTraj[[cellTraj[[2]]]],{}];
childCell[cellTraj_]:=Select[simTraj,#[[2]]==cellTraj[[1]]&,2];

posCellTraj=Table[{},{i,Length[simTraj]}];
dx0Exp=100;
dx0Lin=10;
dx=10;
totalWidth=300;
simTotalTime=Max[Select[simTraj,Length[#[[3]]]>0&][[All,3,-1,1]]];

(*Find how many cells in the population as a function of time*)
nCellsFunctionData=nCellsFunctionData2;
nCellsFunction=nCellsFunction2;
Print[Plot[nCellsFunction[t],{t,0,simTotalTime}]];
nCellsMax=simDataXConc[[1,-1,2]];
(*thicknessFunction[n_]:=Module[{thick1=0.0015,thick2=4*0.0015},thick2 Exp[(n/nCellsMax)*Log[thick1/thick2]]];*)
thicknessFunction[n_]:=Module[{thick1=0.0018,thick2=18*0.0018},(thick2-thick1)*(1/n)+thick1];
Print[Plot[thicknessFunction[n],{n,1,nCellsMax},PlotRange->All]];
(*Return[];*)

Print["simTotalTime = ",simTotalTime];
Print["nb of cell traj = ",Length[simTraj]];

colorGradientBase[x_]:=Blend[{GrayLevel[0.6],Green},x];
colorGradientBase[x_]:=Blend[{Black,Green,Orange},x];
colorGradientBase[x_]:=Blend[{Black,Green},x];
colorGradientBase=ColorData["TemperatureMap"];
colorGradient[xconc_]:=colorGradientBase[Min[Max[(xconc-cmin),0]/(cmax-cmin),1]];

colorCodePlot=
DensityPlot[z,{z,cmin,cmax},{y,0,10},PlotRange->{cmin,cmax},ColorFunction->Function[z,colorGradientBase[z]],PlotRangePadding->None,PlotRangeClipping->False,AspectRatio->1/25,FrameTicks->{{None,None},{{cmin,cmax},None}}
];
Print[colorCodePlot];

plotCellTraj[cellTraj_,x1_,y1_]:=Module[{y2,nSegment=50,dtSegment,segmentList,nCellsTable},
If[Length[cellTraj[[3]]]>1,

y2=cellTraj[[3,-1,1]];
(*y1=cellTraj[[3,1,1]];*)
(*Print["y1 = ",y1," y2 = ",y2];*)
dtSegment=tau/nSegment//.par;
(*Print["dtSegment = ",dtSegment];*)
(*Print["cellTraj = ",cellTraj[[3,;;;;200]]];*)
segmentList=
Join[
{cellTraj[[3,1]]}
,
If[y2>y1+1*dtSegment,
Reap[
Block[{iSegment=1},
Do[
If[i[[1]]>y1+iSegment*dtSegment,
Sow[i];
iSegment++;
]
,{i,cellTraj[[3]]}]
]
][[2,1]]
,{}]
,
{cellTraj[[3,-1]]}
];
(*Print["segmentList = ",segmentList];*)
segmentList=Union[segmentList,SameTest->(#1[[1]]==#2[[1]]&)];
(*Print["segmentList = ",segmentList];*)

nCellsTable=nCellsFunction/@segmentList[[All,1]];
(*Print[nCellsTable];*)

Join[
{{colorGradient[segmentList[[1,1+pos[speciesColor,speciesCell]]]],Thickness[thicknessFunction[nCellsTable[[2]]]],
CapForm["Square"],Line[{{y1,x1},{segmentList[[2,1]],x1}}]
}},
Table[
{colorGradient[segmentList[[iSegment,1+pos[speciesColor,speciesCell]]]],
CapForm["Butt"],Thickness[thicknessFunction[nCellsTable[[iSegment]]]],Line[{{segmentList[[iSegment,1]],x1},{segmentList[[iSegment+1,1]],x1}}]
},{iSegment,2,Length[segmentList]-1}]
,
{Thickness[thicknessFunction[nCellsTable[[-1]]+1]]}
]
,
{}]
];


drawCellTraj[cellTraj_,x1_,y1_]:=Module[{xChild1,xChild2,childCells},

objects=Join[objects,plotCellTraj[cellTraj,x1,y1]];
childCells=childCell[cellTraj];
If[Length[childCells]==2 ,
If[ childCells[[1,1]]<Infinity,
(*
xChild1=x1-dx0Exp N[Exp[-4cellTraj[[3,-1,1]]/simTotalTime]];
xChild2=x1+dx0Exp N[Exp[-4cellTraj[[3,-1,1]]/simTotalTime]];
*)
(*
xChild1=x1-dx0Lin(0.5+2*RandomReal[]);
xChild2=x1+dx0Lin(0.5+2*RandomReal[]) ;
*)
xChild1=xScaleFactor*xcoordinates[[childCells[[1,1]]]];
xChild2=xScaleFactor*xcoordinates[[childCells[[2,1]]]];

(*Draw division line*)objects=Join[objects,{CapForm["Square"],colorGradient[cellTraj[[3,-1,1+pos[speciesColor,speciesCell]]]],Line[{{cellTraj[[3,-1,1]],xChild1},{cellTraj[[3,-1,1]],xChild2}}]}];
(*Print["xChild1 = ",xChild1," xChild2 = ",xChild2];*)
(*Draw child cells*)
(*If[childCells[[1,1]]<=3,*)
drawCellTraj[childCells[[1]],xChild1,cellTraj[[3,-1,1]]];
drawCellTraj[childCells[[2]],xChild2,cellTraj[[3,-1,1]]];
(*];*)
];
];
];

initialCellsTraj=Select[simTraj,Length[parentCell[#]]==0&];

Do[
drawCellTraj[iCell,xScaleFactor*xcoordinates[[iCell[[1]]]],0];
,{iCell,initialCellsTraj(*simTraj[[150;;150]]*)}];

treePlotObjects=objects;
treePlotsimTotalTime=simTotalTime;
];
];
100*Max[xcoordinates]
100*Min[xcoordinates]
exportGraph=False;
graphSizeCoeff=If[exportGraph,4,2];

treePlot=
Show[Graphics[
{
treePlotObjects
,
White,Arrowheads[0.02],Arrow[{Scaled[{0,-0.015},{0,0}],Scaled[{0,-0.015},{treePlotsimTotalTime,0}]}],
Inset[Style[Text["time"],FontSize->0.8*graphSizeCoeff*fontsize,FontColor->White,FontFamily->fontFamily],Scaled[{0,-0.02},{treePlotsimTotalTime/2,0}],{Center,Top}],
Inset[Style[Text["0"],FontSize->0.8*graphSizeCoeff*fontsize,FontColor->White,FontFamily->fontFamily],Scaled[{0,-0.03},{0,0}],{Left,Top}],
Inset[Style[ToString[StringForm["``",NumberForm[treePlotsimTotalTime,1]]],FontSize->0.8*graphSizeCoeff*fontsize,FontColor->White,FontFamily->fontFamily],Scaled[{0,-0.03},{treePlotsimTotalTime,0}],{Right,Top}]
,
Inset[
Show[colorCodePlot,FrameTicksStyle->Directive[FontFamily->fontFamily,FontColor->White,FontSize->graphSizeCoeff*0.8*fontsize],ImagePadding->graphSizeCoeff*{{5,8},{18,2}}
,Epilog->{
Inset[Style["u (nM)",FontFamily->fontFamily,FontColor->White,FontSize->graphSizeCoeff*0.8fontsize],Scaled[{0.5,0}],{Center,Top}]
}]
,{treePlotsimTotalTime/2,100*Max[xcoordinates]},{Center,Bottom},treePlotsimTotalTime/2]

}
],
PlotRangePadding->Scaled[0.01],ImageSize->graphSizeCoeff*imagesize,AspectRatio->1/1.2,Background->GrayLevel[0.2]];
If[!exportGraph,Print[treePlot];];
If[exportGraph,
Export[growingDirectory<>"/exponential_growth.png",treePlot];
]

Movie
Color gradient functions
colorGradientBase[x_]:=Blend[{Black,Green},x];
cmax=1;
cmin=0.05;
colorGradientScaling[y_]:=Log[10,Max[y/cmin,1]]/Log[10,cmax/cmin];
colorGradient[xconc_]:=colorGradientBase[colorGradientScaling[xconc]];
Plot[colorGradientScaling[xconc],{xconc,cmin,cmax},AxesOrigin->{0,0},PlotRange->All]

colorGradientScaling[y_]:=(y-cmin)/cmax;
colorGradient[xconc_]:=colorGradientBase[colorGradientScaling[xconc]];
Plot[colorGradientScaling[xconc],{xconc,cmin,cmax},AxesOrigin->{0,0},PlotRange->All]
Graphics[Table[{colorGradient[x],Disk[{x/cmax,0},0.2]},{x,cmin,cmax,0.1}],ImageSize->150]
Fade-in and fade-out for the title Wild-type / Mutant
Plot[Piecewise[{{1/tfadejt,jt<tfade},{1,jt<tfade+tstay},{1-1/tfade(jt-tfade-tstay),jt<2tfade+tstay}},0]/.{tfade->50,tstay->100},{jt,0,300},ImageSize->150]
Animate[
Text[Style["Wild type",FontSize->60*600/1000,Bold,FontColor->Yellow,Opacity[Piecewise[{{1/tfadejt,jt<tfade},{1,jt<tfade+tstay},{1-1/tfade(jt-tfade-tstay),jt<2tfade+tstay}},0]/.{tfade->50,tstay->100}]],Background->Gray]
,{jt,1,200},AnimationRate->25]
Read simulation data
inputPath="/home/mweber/apterous/Research/Simulations/Output/Ising_model/Toy_model/Stochastic/ExponentialGrowth/Gillespie/Dx5.000e+00";
iTrajectory=1;
SetDirectory[inputPath];
(*simDataX=Table[Drop[Import["x_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];*)
simDataXConc=Table[Drop[Import["xConc_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,iTrajectory,iTrajectory}];
simCellsVolume=Table[Drop[Import["volumes_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,iTrajectory,iTrajectory}];
simDataAngle=Table[Drop[Import["angle_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,iTrajectory,iTrajectory}];
simDataPosition=Table[Drop[Import["position_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,iTrajectory,iTrajectory}];
simDataLineage=Table[Drop[Import["cell_lineage_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,iTrajectory,iTrajectory}];
inputPath2="/home/mweber/DATA/PROGS/OUTPUT/QS_precision2/mutant/lux01_induction/10h/AIxAdded40.000";
nTrajectories=1;
SetDirectory[inputPath2];
simDataXConc2=Table[Drop[Import["xConc_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
simCellsVolume2=Table[Drop[Import["volumes_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
simDataAngle2=Table[Drop[Import["angle_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
simDataPosition2=Table[Drop[Import["position_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
simDataLineage2=Table[Drop[Import["cell_lineage_traj"<>intstring[iTraj-1]<>".dat","CSV"],-1],{iTraj,nTrajectories}];
Dimensions[simDataXConc[[1]]]
25*120
Compute movie
simDataXConc[[1,-1,3]]
simDataXConc[[1,-1,3]]
Length[Select[simDataXConc[[1]],(FractionalPart[#[[3]]/(5*timeMeshSliceLength)]<1*^-15)&&#[[3]]>350&]]
%/25.
Module[{drawSize,timestep,xx,xxt,xxangle,xxanglet,xxvolumes,xxvolumest,xxconc,xxconct,xxAIxconct,nCells,time,nt,it,drawSuppositoire,xxCellLength,xxtime,simTraj,frame,frameLegend,printLegend,printRequCircle,exportMovie,printAnimate,testRun,cAIxmax,timeStart=350,
simXconc=simDataXConc[[1]],
simVolume=simCellsVolume[[1]],
simAngle=simDataAngle[[1]],
simPosition=simDataPosition[[1]],V00=V0/.par,cellLength0=cellLength0/.par,cellHeight0=cellHeight0/.par,magnifier=1,fieldOfViewSize,magnifierTimeFunction,useMagnifierTimeFunction,
doubleSim,simXconc2,simVolume2,simAngle2,simPosition2,frameDoubleSim,
species,posSpecies,cmax,cmin,colorGradient,colorGradientAIx,colorGradientBase,colorGradientBaseAIx},

testRun=True;
doubleSim=False;
useMagnifierTimeFunction=True;
timeMeshSliceLength=0.01;
drawSize=Round[800,16];(*must be a multiple of 16 for better movie encoding*)
exportMovie=!testRun;
printAnimate=testRun;
printLegend=True;
printRequCircle=False;

species=U;posSpecies=pos[species];
(*Select the time steps which are multiples values of the time mesh. Discard intermediate steps due to cell divisions or cell death.*)
timestep=5*timeMeshSliceLength;
simXconc=Select[simXconc,(FractionalPart[#[[3]]/timestep]<1*^-15)&&#[[3]]>timeStart&];
simVolume=Select[simVolume,(FractionalPart[#[[3]]/timestep]<1*^-15)&&#[[3]]>timeStart&];
simAngle=Select[simAngle,(FractionalPart[#[[3]]/timestep]<1*^-15)&&#[[3]]>timeStart&];
simPosition=Select[simPosition,(FractionalPart[#[[3]]/timestep]<1*^-15)&&#[[3]]>timeStart&];

If[doubleSim,
simXconc2=simDataXConc2[[1]];
simVolume2=simCellsVolume2[[1]];
simAngle2=simDataAngle2[[1]];
simPosition2=simDataPosition2[[1]];
simXconc2=Select[simXconc2,(FractionalPart[#[[3]]/timeMeshSliceLength]<1*^-15)&];
simVolume2=Select[simVolume2,(FractionalPart[#[[3]]/timeMeshSliceLength]<1*^-15)&];
simAngle2=Select[simAngle2,(FractionalPart[#[[3]]/timeMeshSliceLength]<1*^-15)&];
simPosition2=Select[simPosition2,(FractionalPart[#[[3]]/timeMeshSliceLength]<1*^-15)&];
];

nt=Length[simXconc];
Print["nt = ",nt];
xxconct[simXconc_,jt_,iCell_]:=extractX[simXconc,species,jt,iCell];
xxAIxconct[simXconc_,jt_]:=extractAIx[simXconc,jt];
xxt[simPosition_,jt_,iCell_]:=magnifier*(extractPosition[simPosition,jt,iCell]-0.5)+{0.5,0.5};
nCells[simPosition_,jt_]:=(Length[simPosition[[jt]]]-3)/2;
time[simXconc_,jt_]:=extractTime[simXconc,jt];
xxanglet[simAngle_,jt_,iCell_]:=extractAngle[simAngle,jt,iCell];
xxvolumest[simVolume_,jt_,iCell_]:=extractVolume[simVolume,jt,iCell]/V00;

(*PRINT OUT CONCENTRATIONS IN COLOR CODE*)
cmin=0;Print["cmin = ",cmin];
cmax=10;Print["cmax = ",cmax];
(*colorGradientBase=ColorData["AvocadoColors"];*)
colorGradientBase[x_]:=Blend[{GrayLevel[0.6],Green},x];
colorGradientBase[x_]:=Blend[{Black,Green},x];
colorGradient[xconc_]:=
colorGradientBase[Min[Max[(xconc-cmin),0]/(cmax-cmin),1]];
Print[Graphics[Table[{colorGradientBase[x],Disk[{x,0},0.2]},{x,0,1,1/8}],ImageSize->150]];

(*PRINT OUT CONCENTRATION OF AIX IN COLOR CODE FOR THE BACKGROUND*)
cAIxmax=10;Print["cAIxmax = ",cAIxmax];
colorGradientBaseAIx[x_]:=Blend[{Opacity[1,GrayLevel[0.6]],Opacity[1,Lighter[Blue,0.3]]},x];
colorGradientAIx[AIxconc_]:=
colorGradientBaseAIx[Min[AIxconc/cAIxmax,1]];
Print[Graphics[Table[{colorGradientBaseAIx[x],Disk[{x,0},0.2]},{x,0,1,1/8}],ImageSize->150]];

(*FUNCTION TO DRAW THE CELLS*)
drawSuppositoire[x_,l_,h_,θ_,DivisionLine_,color_,divisionColorBorder_]:=
Module[{output,pts,nPointsCircle,polygon,line},
nPointsCircle=16;
pts=Join[{{-(l-h)/2,h/2},{(l-h)/2,h/2}},
Table[{(l-h)/2,0}+{(h/2)Cos[angle],(h/2)Sin[angle]},{angle,Pi/2,-Pi/2,-Pi/nPointsCircle}],
{{(l-h)/2,-h/2},{-(l-h)/2,-h/2}},
Table[{-(l-h)/2,0}+{(h/2)Cos[angle],(h/2)Sin[angle]},{angle,3Pi/2,Pi/2,-Pi/nPointsCircle}]];
polygon=Translate[Rotate[Polygon[pts],π θ/180,{0,0}],x];
line=Translate[Rotate[Line[{{0,-h/2},{0,h/2}}],π θ/180,{0,0}],x];
output={color,EdgeForm[{GrayLevel[0.7],Thickness[0.04]}],polygon};
If[DivisionLine,output={color,EdgeForm[{divisionColorBorder,Thick}],polygon,divisionColorBorder,Thick,line}];
output
];

Print[Graphics[drawSuppositoire[xxt[simPosition,1,1],cellLength0*xxvolumest[simVolume,1,1]/V00,cellHeight0,xxanglet[simAngle,1,1],False,colorGradient[xxconct[simXconc,1,1]],Red]]];


(*DRAWING THE FRAMES*)
frameLegend=Panel[Row[{
Column[{Style[ToString[species]<>"(t) (nM)",FontSize->30*drawSize/1000],
Rasterize[ParametricPlot[{x,y},{x,cmin,cmax},{y,0,1},Mesh->None,ColorFunction->(colorGradientBase[#]&),Frame->{True,False,False,False},FrameTicks->{{None,None},{{0,Round[cmax]},None}},FrameTicksStyle->Directive[FontSize->30*drawSize/1000],AspectRatio->0.2,ImageSize->200*drawSize/1000,Background->LightGray],Background->LightGray]
}],
Column[{Style["AIx(t) (nM)",FontSize->30*drawSize/1000],
Rasterize[ParametricPlot[{x,y},{x,0,cAIxmax},{y,0,1},Mesh->None,ColorFunction->(colorGradientBaseAIx[#]&),Frame->{True,False,False,False},FrameTicks->{{None,None},{{0,cAIxmax},None}},FrameTicksStyle->Directive[FontSize->30*drawSize/1000],AspectRatio->0.2,ImageSize->200*drawSize/1000,Background->LightGray],Background->LightGray]
}]
},"   "]];
Print[frameLegend];

(*Calculate initial field of view size as the final radius of the colony*)
fieldOfViewSize=2*1.2*N[Sqrt[(nCells[simPosition,-1]*cellLength0/Log[2]*cellHeight0)/Pi]];

magnifierTimeFunction[jt_]:=Module[{zoomValuesTable={{1.6,0},{1.1,0.25},{1.1,1},{1.1,1.1}},transitionTime=50/nt,piecewiseTable},
piecewiseTable={};
Do[
piecewiseTable=Join[piecewiseTable,{{zoomValuesTable[[iStep-1,1]],zoomValuesTable[[iStep-1,2]]<jjt<=zoomValuesTable[[iStep,2]]-transitionTime},
{zoomValuesTable[[iStep-1,1]]-(zoomValuesTable[[iStep-1,1]]-zoomValuesTable[[iStep,1]])/transitionTime (jjt-(zoomValuesTable[[iStep,2]]-transitionTime)),zoomValuesTable[[iStep,2]]-transitionTime<jjt<=zoomValuesTable[[iStep,2]]}}];
,{iStep,2,Length[zoomValuesTable]}];
Piecewise[piecewiseTable//.jjt->jt]
];
Print["Magnifier (zoom) function:\n",Plot[magnifierTimeFunction[jt],{jt,0,1},ImageSize->200]];

frame[jt_]:=Module[{jjt=If[jt<0,nt-jt,jt]},
Style[Graphics[{
{colorGradientAIx[xxAIxconct[simXconc,jt]],Disk[{0,0},0.55]},
Scale[
Table[{
If[(*Norm[xxt[simPosition,jt,iCell]-{0,0}]*)0<fieldOfViewSize/2+cellLength0,
{drawSuppositoire[xxt[simPosition,jt,iCell],cellLength0*xxvolumest[simVolume,jt,iCell],cellHeight0,xxanglet[simAngle,jt,iCell],False,colorGradient[xxconct[simXconc,jt,iCell]],Red]},{}]
}
,{iCell,nCells[simPosition,jt]}]
,1/fieldOfViewSize*If[useMagnifierTimeFunction,magnifierTimeFunction[jjt/nt],1],{0,0}]
(*,Inset[Panel[Row[Style[#,FontSize->30*drawSize/1000]&/@{"time ",PaddedForm[time[simXconc,jt]/60,{4,1},NumberPadding->{" ","0"}]," (h)"}]],{-0.58,0.58},{Left,Top}]*)
(*,
If[printLegend,Inset[frameLegend,{0.58,0.58},{Right,Top}],{}]
*)},
PlotRangePadding->0,ImageSize->drawSize,PlotRange->{{-0.6,0.6},{-0.6,0.6}},Background->colorGradientAIx[0]],Antialiasing->True]];

frameDoubleSim[jt_]:=Style[Graphics[{
{colorGradientAIx[xxAIxconct[simXconc,jt]],Disk[{0.5,0.5},0.55]},
Table[{
If[Norm[xxt[simPosition,jt,iCell]-{0.5,0.5}]<0.5+cellLength,
{drawSuppositoire[xxt[simPosition,jt,iCell],cellLength*xxvolumest[simVolume,jt,iCell],cellHeight,xxanglet[simAngle,jt,iCell],False,colorGradient[xxconct[simXconc,jt,iCell]],Red]},{}]
}
,{iCell,nCells[simPosition,jt]}],

{colorGradientAIx[xxAIxconct[simXconc2,jt]],Disk[{1.65,0.5},0.55]},
Table[{
If[Norm[xxt[simPosition2,jt,iCell]-{0.5,0.5}]<0.5+cellLength,
{drawSuppositoire[xxt[simPosition2,jt,iCell]+{1.15,0},cellLength*xxvolumest[simVolume2,jt,iCell],cellHeight,xxanglet[simAngle2,jt,iCell],False,colorGradient[xxconct[simXconc2,jt,iCell]],Red]},{}]
}
,{iCell,nCells[simPosition2,jt]}],

Inset[
Text[Style["Wild type",FontSize->60*drawSize/1000,Bold,FontColor->Yellow,Opacity[Piecewise[{{1/tfade jt,jt<tfade},{1,jt<tfade+tstay},{1-1/tfade (jt-tfade-tstay),jt<2tfade+tstay}},0]/.{tfade->50,tstay->100}]
]],{0.5,0.8},{Center,Top}],

Inset[
Text[Style["Mutant",FontSize->60*drawSize/1000,Bold,FontColor->Yellow,
Opacity[Piecewise[{{1/tfade jt,jt<tfade},{1,jt<tfade+tstay},{1-1/tfade (jt-tfade-tstay),jt<2tfade+tstay}},0]/.{tfade->50,tstay->100}]
]],{1.65,0.8},{Center,Top}
],

Inset[Panel[Row[Style[#,FontSize->30*drawSize/1000]&/@{"time ",PaddedForm[time[simXconc,jt]/60,{4,1},NumberPadding->{" ","0"}]," (h)"}]],Scaled[{0.02,0.98}],{Left,Top}],
If[printLegend,Inset[frameLegend,Scaled[{0.98,0.98}],{Right,Top}],{}]
},PlotRangePadding->0,ImageSize->{Automatic,drawSize},PlotRange->{{-0.1,2.25},{-0.1,1.1}},Background->colorGradientAIx[0]],Antialiasing->True];


(*EXPORTING IMAGES*)
If[exportMovie,
Module[{fileNameTable},
CreateDirectory[inputPath<>"/movie/png"];
SetDirectory[inputPath<>"/movie/png"];
DeleteFile[FileNames["*.png"]];
fileNameTable=Table["image"<>StringDrop[ToString[PaddedForm[jt,4,NumberPadding->{"0",""}]],{1,1}]<>".png",{jt,1,nt+1}];
Do[
Export[fileNameTable[[jt]],
Style[
If[doubleSim,
frameDoubleSim[jt],
frame[jt]]
,Antialiasing->True]
,ImageSize->{Automatic,drawSize},"CompressionLevel"->0,ColorSpace->RGBColor,Background->White];Print[jt," /",nt];
,{jt,1,nt,1}];
];
Print["Images exported."];
];

If[printAnimate,
If[doubleSim,
Print[frameDoubleSim[30]];
Print[frameDoubleSim[-1]];
,
Do[
Print[frame[Max[1,Ceiling[i*nt]]]];
,{i,0,1,0.05}]
];
];

(*ANIMATION*)
(*
If[printAnimate,
Print[Animate[
frame[jt]
,{jt,1,10,1},AnimationRepetitions->1,AnimationRunning->True,DisplayAllSteps->True]]
];
*)
]